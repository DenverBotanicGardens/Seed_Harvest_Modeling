---
title: "Seed Harvest IPM and MPM"
author: "Michelle DePrenger-Levin"
date: "7/26/2020"
output: html_document
---

Example data for Sclerocactus glaucus where size measurements are the width at widest point for these ball cacti
't0' and 't1' are the widths (cm) and survival is for the tagged cactus from year t to t+1. 'reproyesno' is for 't0'. 'flowers0' is a Poisson distribution based on a linear model of number of flowers by size on the one year we took that data. 'minis0' and 'minis1' are the number of seedlings (cacti with < 0.5 cm in width) in year t and t+1
```{r}

rm(list=ls())
library(dplyr)
library(popbio)
library(MuMIn)
library(binr)
library(matrixStats)
require(AICcmodavg)
library(prism)
library(raster)
library(lme4)
library(ggplot2)

# download the Rdata files into your working directory, set your working directory and load them
setwd("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/")
load("size_scgl.Rda") # data converted to yearly transition
load("allsdszs_scgl.Rda") # only individuals that were < 0.5 and considered seedlings
# load("size_scgl1.Rda")

```


functions   
```{r}
# Seeds a populaiton with 100 indiviudals in the smallest size class, removes the top row (so no more reproduction), and follows the population until all have died. Based on a deterministic matrix
lifespan <- function(nx){
  nclasses=dim(nx)[1]
  vec=c(100,rep(0,(nclasses-1)))
  nx[1,]=0
  jj=1
  while (sum(vec)>1){
    vec=nx%*%vec
    jj=jj+1
    #print(sum(vec))
  }
  return(jj)
}

# Need to add clustered collection (not included yet). Good or Bad years determined by high and low fecundity, Output for further analysis: string of good and bad years, string of years with harvest, rate of harvest in harvested years, population size each year
# Add density dependence - how to determine k (ceiling of growth)
SeedHarvestSim <- function(Mx_list, TMx_list, Nx, StartPopSize, GoodBadTm, Freq = c(0,0), Int = c(0,0), TotYrs, ClusteredColl = "N", seedbank = FALSE){
  
  if(rowSums(GoodBadTm)!=2) print("Error: chance of transitioning from a 'good' year to 'good' or 'bad' must sum to 1 (ditto for bad:good or bad)")
  
  vec <- floor(Nx*(StartPopSize/sum(Nx)))
  
  # Seed Harvest Rates, frequency, probability of harvest in a given year and intensity or percent of seed harvested
  Freq_m <- matrix(Freq, nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Freq")))
  Inten_m <- matrix(Int, nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Inten")))
  
  # if Lambda is the cutoff for good vs. bad year
  l_all <- sapply(Mx_list, function(x)  lambda(t(x)), simplify = FALSE, USE.NAMES = TRUE) 
  mn_l <- mean(unlist(l_all))
  above_l <- Mx_list[which(l_all >= mn_l)]
  below_l <- Mx_list[which(l_all < mn_l)]
  # If fecundity is the cutoff (practical sense of a good year with lots of seed vs few seed produced) but this doesn't really tell me if there is high production of seed, it's the ratio of seed production to recruitment
  f_all <- mapply(function(x,y){
    fec <- x-y
    rowSums(fec)[1] #Only the first row is funcunity across classes (subtracted out survival by Mx-TMx)
    }, Mx_list, TMx_list)
  mn_f <- mean(unlist(f_all)) 
  above_f <- Mx_list[which(f_all >= mn_f)]
  below_f <- Mx_list[which(f_all < mn_f)]
  
  # Start with good! positive
  Yr <- "Good"
  GBs <- rep(NA,TotYrs)
  Freqs <- rep(NA,TotYrs)
  Intens <- rep(NA,TotYrs)
  PopSize <- c(sum(vec),rep(NA, TotYrs))
  yrs <- 1
  while(yrs <= TotYrs){
    if(Yr == "Good"){
      nx <- above_f[[sample(1:length(above_f), 1)]] # randomly sample from the high fecundty transition matrices
    } else {
      nx <- below_f[[sample(1:length(below_f), 1)]]
    }
    # Freq likely to collect seed in good or bad years
    CollectYN <- rbinom(1,1,Freq_m[Yr,])
    if(CollectYN == 1){
      # yes collect, reduce fecuntity by how much?
      if(seedbank == TRUE){ 
        nx[1,-1] <- nx[1,-1]*Inten_m[Yr,] 
      } else {
        nx[1,] <- nx[1,]*Inten_m[Yr,]
      }
    }
    
    # Multiple N_t+1 = M*N_t
    vec <- nx%*%vec
    
    GBs[yrs] <- Yr
    Freqs[yrs] <- CollectYN
    if(CollectYN==1){
      Intens[yrs] <- Inten_m[Yr,]
    }
    PopSize[(yrs+1)] <- sum(vec)
    # Transition between good and bad years
    Yr <- if(rbinom(1,1,GBmatrix[Yr,1])==1){
      "Good"
    } else {
        "Bad"
      } 
    Yr
    yrs <- yrs+1
  }  
  list(GB_yrs = GBs, Frequency = Freqs, Intensity = Intens, PopulationSize = PopSize)
}


```



# Matrix Population Models

lambda ~ fecundity
```{r}
load("C:/Users/deprengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/PVA/Paniw etal/patterns_temporal_autocorrelation-master/COMPADRE_v.4.0.0.RData")

# Ellis et al. 2012 paper
tm <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Kaye_transitionmatrices.csv")

sp_info <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Kaye_speciesinfo.csv")

m1 <- gsub("\\[|\\]", "", tm$Mx[100]) 
m2 <- strsplit(m1, ";")  # remove the ";" that separates rows
(m3 <- lapply(m2, function(x) strsplit(trimws(x,"l"), " "))) # split each list element after removing leading whitespace
(m4 <- matrix(as.numeric(unlist(m3)), nrow = length(m3[[1]][[1]]), byrow = TRUE))
# Mx: Annual transition matrix
# Tmx: Annual trnasition matrix with transition probabilities, no fecundity
# Nx: Vector of observed stage structures (counts in each stage); must be at the start

Nx_all <- lapply(1:nrow(tm), function(i){
  v1 <- gsub("\\[|\\]", "", tm$Nx[i])
  v2 <- sapply(v1, function(x) strsplit(trimws(x,"l"), " ")) 
  v3 <- as.numeric(unlist(v2[[1]]))
  v3
})

Nx_names <- lapply(1:nrow(tm), function(i){
  spp <- tm$SPP[i]
  pop <- tm$POP[i]
  yr <- tm$YR[i]
  paste(spp, pop, yr)
})

names(Nx_all) <- Nx_names

# Validate structure of matrices with an example
Nx_all[[100]]
Nx_names[[100]] # Dicerandra fruitescens: short lived (<10 years); fire; recorded quarterly; 6 identified stages: (1) seed bank, seedlings, (3) vegetative, (4) small fl, (5) med fl, (6) large fl.; seedbank from simulation see Menges et al. 2006

# Transitions without fecundity
TMx_all <- sapply(1:nrow(tm), function(i){
  m1 <- gsub("\\[|\\]", "", tm$Tmx[i])
  m2 <- strsplit(m1, ";")  # remove the ";" that separates rows
  m3 <- lapply(m2, function(x) strsplit(trimws(x,"l"), " ")) # split each list element after removing leading whitespace
  m4 <- matrix(as.numeric(unlist(m3)), nrow = length(m3[[1]][[1]]), byrow = TRUE)
  m4
}, simplify =FALSE, USE.NAMES = TRUE)

names(TMx_all) <- Nx_names

# Transitions and fecundity
Mx_all <- sapply(1:nrow(tm), function(i){
  m1 <- gsub("\\[|\\]", "", tm$Mx[i])
  m2 <- strsplit(m1, ";")  # remove the ";" that separates rows
  m3 <- lapply(m2, function(x) strsplit(trimws(x,"l"), " ")) # split each list element after removing leading whitespace
  m4 <- matrix(as.numeric(unlist(m3)), nrow = length(m3[[1]][[1]]), byrow = TRUE)
  m4
}, simplify =FALSE, USE.NAMES = TRUE)

names(Mx_all) <- Nx_names
Mx_all[grep("ASSC", names(Mx_all))]

lambdas <- sapply(Mx_all, function(x) lambda(x), simplify = FALSE, USE.NAMES = TRUE)

fecundity <- mapply(function(x,y){ 
  fec <- x-y
  rowSums(fec)[1] #Only the first row is funcunity across classes (subtracted out survival by Mx-TMx)
  }, Mx_all, TMx_all)

x <- unique(tm$SPP)[3]
# Help! errors with CIPI becuase one population had 6 stages while three others have 3 stages. Why are some crazy long-lived?? ASSC has dormant as stage 1; Starting with all individuals as dormant. The life length calculation doesn't allow for that...
# unlimited growth! Clearly there must be some density dependency and that needs to be entered for life length

# nx <- mean(Mx_all[grep("ASSC", unlist(Nx_names))])
nx <- Mx_all[grep("ASSC", unlist(Nx_names))]
nclasses <- dim(nx[[1]])[1]
vec <- c(0, 100, rep(0,(nclasses-2))) # since the first class is dormant and the second class are the little ones
nx <- sapply(nx, simplify = FALSE, USE.NAMES = TRUE, function(x){
  x[1,] <- 0 # made all reproduction zero
  x
  })
jj <- 1
# Check what is happening
  # repeat{
  #   print(vec <- nx%*%vec)
  #   print(jj <- jj+1)
  #   if(is.na(sum(vec))) break
  #   }
while(sum(vec)>1){
  nx_r <- nx[[sample(1:length(nx), 1)]] # randomly sample from the matrices instead of a deterministic 
  vec <- nx_r%*%vec
  jj <- jj+1
}
lifespan_ASSC <- jj

 

# Silene acaulis could be super long lived, maybe, but it also has seeds in the seed bank that likely stay there a few years so this is following 100 seeds
nx <- mean(Mx_all[grep("SIAC", unlist(Nx_names))])
nclasses <- dim(nx)[1]
vec <- c(0, 100, rep(0,(nclasses-2))) # since the first class is seed bank and the second class are the seedlings
  nx[1,] <- 0 # made all reproduction zero
jj <- 1
while(sum(vec)>1){
  (vec <- nx%*%vec)
  jj <- jj+1
}
lifespan_ASSC <- jj
rowSums(nx)

sp_info[sp_info$Unobserved.stages>0,]

x <- unique(tm$SPP)[2]

# stochastic, not deterministic, 
lifespans <- lapply(unique(tm$SPP), function(x){
  if(x == "CIPI"){
    Mx_sp <- Mx_all[grep(x, unlist(Nx_names))]
    Mx_sp <- Mx_sp[grep("CIPI_4", names(Mx_sp), invert = TRUE)] # just ignore for now the one site with 6 stages instead of 3
  } else {
    Mx_sp <- Mx_all[grep(x, unlist(Nx_names))]
    }
  nclasses <- dim(Mx_sp[[1]])[1]
  if(x %in% c("ASSC","DIFR","ERCU","HYCU","LAVE","NEMA","PHEM","PHIN","SIAC")){ # Ones where the first stage is not seedlings
    vec <- c(0, 100, rep(0,(nclasses-2))) 
  } else{
    vec <- c(100, rep(0,(nclasses-1))) # a population of 100 individuals in the smallest size, zero in all others
  }
  Mnx <- sapply(Mx_sp, simplify = FALSE, USE.NAMES = TRUE, function(x){
    x[1,] <- 0 # made all reproduction zero
    x
    }) # made all reproduction zero
  jj <- 1
  while(sum(vec)>1){
    (nx <- Mnx[[sample(1:length(Mnx), 1)]])
    (vec=nx%*%vec)
    jj<- jj+1 # Lives another year until all the individuals are dead (because we got rid of reproduction)
    }
  jj
  })

names(lifespans) <- unique(tm$SPP)[-2]

```


```{r}
# Is fecundity correlated to lambda
all_summarydata <- data.frame(SPPSiteYr = names(lambdas), SPP = tm$SPP, lmbd = unlist(lambdas), f = unlist(fecundity))
all_summarydata <- merge(all_summarydata, sp_info, by = "SPP")

# for which are fecundity and lambda correlated
lm1 <- lm(lmbd ~ f, data = all_summarydata)
lm2 <- lm(lmbd ~ f * Genus, data = all_summarydata)
lm3 <- lm(lmbd ~ f * Number.of.stages, data = all_summarydata)

lm.list <- list(lm1, lm2, lm3)
lm.names <- as.character(unlist(lapply(lm.list, formula)))
(lm.results <- aictab(lm.list, modnames = lm.names))

# evidence ratio
for(i in 2:length(lm.list)){
  print(exp(0.5*lm.results$Delta_AICc[i]))
}

summary(lm2)

# fecundity doesn't vary for some. 
ggplot(all_summarydata, aes(f, lmbd, colour = Genus))+
  geom_point()+
  stat_smooth(method = "lm")+
  theme_bw()+
  facet_wrap(~Genus, scales="free")+
  theme(legend.position="none")+
  ylab("lambda")+
  xlab("fecundity")
```

##### Make S4 objects later as output of simulation
```{r}
# To start with checking DIFR and then build out simulation function by species
which(unique(tm$SPP) %in% "DIFR")
sp <- unique(tm$SPP)[5]

# from row to column (differ from MPM)
GBmatrix <- matrix(c(0.25,0.75,0.15,0.85), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad")))

### Want to add in increased chance of collecting a few years in a row to mimic a grant or short time project

GoodBadTm <- GBmatrix
Freq <- c(0.2,0.05)
Int <- c(0.2,0.5)

StartPopSize <- 300
sum(floor(Nx_all[[1]]*(100/sum(Nx_all[[1]]))))

## Nx could be the stable state distribution or the starting size distribution (counts of each stage) and will be scaled to desired pop size

testfoo <- SeedHarvestSim(Mx_list = Mx_all[grep("DIFR", unlist(Nx_names))], 
                          TMx_list = TMx_all[grep("DIFR", unlist(Nx_names))],
                          Nx = stable.stage(mean(Mx_all[grep("DIFR", unlist(Nx_names))])),
                          StartPopSize = 500,
                          GoodBadTm = GBmatrix,
                          # Freq = c(.1,.1), # skip for now, just project with high or low fecundity
                          Int = c(0.1,0.5),  # Skip for now but project with higher intensity in bad years to make reasonable sized collections
                          TotYrs = 100,
                          # ClusteredColl = "Y", # Skip for now, need to work into the function that if a collection is made, how many consecutive years after are there collections despite or with regard to good/bad
                          seedbank = TRUE) # If there is a seedbank class, it needs to be skipped in reducing fecundity of the first row (skip that first column)

testfoo_rand <- SeedHarvestSim(Mx_list = Mx_all[grep("DIFR", unlist(Nx_names))], 
                          TMx_list = TMx_all[grep("DIFR", unlist(Nx_names))],
                          Nx = stable.stage(mean(Mx_all[grep("DIFR", unlist(Nx_names))])),
                          StartPopSize = 15000,
                          GoodBadTm = matrix(c(0.5,0.5,0.5,0.5), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad"))),
                          TotYrs = 100,
                          # ClusteredColl = "Y", # Skip for now, need to work into the function that if a collection is made, how many consecutive years after are there collections despite or with regard to good/bad
                          seedbank = TRUE)


TMx_all[[100]];Mx_all[[100]];Nx_all[[100]];Nx_names[[100]];fecundity[[100]]
lapply(grep("DIFR", unlist(Nx_names)), function(x) lifespan(Mx_all[[x]])) 
dim(Mx_all[x])

TMx_all[grep("DIFR",unlist(Nx_names))]
plot(testfoo_rand$PopulationSize, type="l")
lines(testfoo$PopulationSize, col="red")
```

No seed harvest to seed harvest across starting population sizes
```{r}

sizes_tenpercent <- lapply(c(10, 50, 100, 500, 1000), function(popsz){
  lapply(unique(tm$SPP)[1], function(sp){
    if(sp %in% c("ASSC","DIFR","ERCU","HYCU","LAVE","NEMA","PHEM","PHIN","SIAC")){ # first stage not seedlings
      sb <- "TRUE"
    } else {
        sb <- "FALSE"
      }
    out <- SeedHarvestSim(Mx_all[grep(sp, unlist(Nx_names))],
                          TMx_all[grep(sp, unlist(Nx_names))],
                          Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
                          StartPopSize = popsz,
                          GoodBadTm = matrix(c(0.5,0.5,0.5,0.5), nrow=2, byrow = TRUE, 
                                             dimnames = list(c("Good","Bad"), c("Good","Bad"))),
                          TotYrs = 100,
                          # ClusteredColl = "Y", # Skip for now, need to work into the function that if a collection is made, how many consecutive years after are there collections despite or with regard to good/bad
                          seedbank = sb)
    })
  out
  })







```






# Integral projeciton models
Merow et al 2014 Advancing population ecology   
```{r}

# make an S4 class object? 
params <- data.frame(
  surv.int=NA, # Intercept from logistic regression of survival
  surv.slope=NA, # Slope from logistic regression of survival
  growth.int=NA, # Intercept from linear regression of growth
  growth.slope=NA, # Slope from linear regression of growth
  growth.sd=NA, # Residual sd from the linear regression of growth
  seed.int=NA, # Intercept from Poisson regression of seed number
  seed.slope=NA, # Slope from Poisson regression of seed number
  recruit.size.mean=NA, # Mean recruit size
  recruit.size.sd=NA, # Standard deviation of recruit size
  establishment.prob=NA # Probability of establishment
)
```


# build vital rate regressions and store coefficients  
# Assume most populaitons will have different responses by site but check. Limitation might be due to sample (populaiton) size leading to lumping or splitting data by population. 
```{r}
# example data frame
size_scgl

# Test if there are differences in vital rates among sites and years

ggplot(size_scgl, aes(t0, survival, colour = Site))+
  geom_point()+
  theme_bw()+
  geom_jitter(height = 0.1, width = 0)+
  facet_wrap(~Site)

ggplot(size_scgl, aes(t0, survival, colour = Site))+
  geom_point()+
  theme_bw()+
  geom_jitter(height = 0.1, width = 0)+
  facet_wrap(~year0)

# survival
surv.reg1 <- glm(survival ~ t0 + Site + as.factor(year0), data = size_scgl, family = binomial()) # survival by size (slope) comparing different intercepts by site and year
surv.reg2 <- glm(survival ~ t0, data = size_scgl, family = binomial()) # survival by size (slope)
# Could compare different slope and intercept by site and year but doesn't that overfit??

reg.list <- list(surv.reg1, surv.reg2)
reg.names <- as.character(unlist(lapply(reg.list, formula)))
(reg.results <- aictab(reg.list, modnames = reg.names))

summary(surv.reg1)

params$surv.int <- c(rep(coefficients(surv.reg1)[1], length(coefficients(surv.reg1))-2)+coefficients(surv.reg1)[-c(1:2)] )# all the offsets for year and site
```



# Code adapted from Dan Doak for an IPM

```{r}

# Unknown, test correlation of t-1, t-2 ... reproductive output on seedlings to see if there's an indication of a persistent seed bank
seedlings_per_seed_sg <- 10/500 # 0.000001 # the rate that a seed germinates I'm making a wild estimate

# Changed our methods from measuring all individuals to only measuring individuals >= 0.5 cm width in 2012. 
surv_minis <- 0.69 # this is an average of two estimates, should test both 0.59 and 0.78

# set the minimum size and maximum size
minsize_scgl <- 0.01
maxsize_scgl <- 12.61 # was Fram, excluded 14.51

```


Size density estimation for median size estimation - for each kernel, the state of an individual at one time that dictates the state and state of any offspring at the next time step (Merow et al. 2014 "Advancing population ecology with integral projeciton models: a practical guide")
```{r}

pdfsz_scgl <- density(size_scgl$t0, n=1024, cut=0, na.rm = TRUE)
pdfsz2_scgl <- cbind(pdfsz_scgl$x,pdfsz_scgl$y)
plot(pdfsz2_scgl, type="l")

```

### Matrix Model 
  Estimate vital rates, populate matrix, for models with different numbers of classes/ bins    

```{r ScGl matrix}
# testing
# seedlings_per_seed <- seedlings_per_seed_sg # not sure if this should be the chance a seed turns into a seedling or something else or how to pick the value
# testbins <- c(4,5,6,7,8,10,15,19) # I don't have enough individuals to get estimates if I break this into too many bins
# df <- size_scgl
# minsize <- minsize_scgl
# maxsize <- maxsize_scgl
# bin.num <- testbins
# allsdszs <- allsdszs_scgl # the distribution of sizes you classify as a seedling
# surv_seedlings <- surv_minis # calculated from using the size class defined as seedlings in time t and the annual surival to t+1; seedling size vs. the smallest bin size which might include more than survival of seedlings
# bin.num <-  c(4,5,6,7,8)
# i <- 3
# seeds_per_flower <- 150
# rm(bin.num); rm(i); rm(df);rm(seedlings_per_seed);rm(minsize); rm(maxsize); rm(allsdszs); rm(surv_seedlings); rm(seeds_per_flower)

IPM_basic <- function(df, bin.num, seedlings_per_seed, surv_seedlings, seeds_per_flower, seedling_size){
    # Empty list items
    lambdas_matrix <- rep(NA, length(bin.num))
    dampratio_matrix = rep(NA, length(bin.num))
    lifespan_matrix=rep(NA, length(bin.num))
    mincounts=NULL
    minsize <- min(c(df$t0, df$t1), na.rm=TRUE) -0.01
    maxsize <- max(c(df$t0, df$t1), na.rm=TRUE) +0.01
    allsdszs <- df$t0[df$t0 < seedling_size]
    # test each number of bins, break by size 
    for(i in 1:length(bin.num)){
      ss=as.numeric(df$t0)
      vec.bin = c(minsize, minsize+1:bin.num[i]*(maxsize-minsize)*(1/bin.num[i])) # the upper and lower size limits to make the designated number of bins
      nums=hist(ss,breaks=vec.bin, plot=FALSE)$counts  # the number of individuals that fall in each group
      mincounts=c(mincounts,min(nums))
      
      if (min(nums)>2) {  
        ## Initialize storage
        n.bin <- length(vec.bin)-1            # this is a workaround
        n <- rep(NA, n.bin)                   # count of indvs per bin
        medians <- rep(NA, n.bin)             # median size per bin for F
        surv <- rep(NA, n.bin)                # survivorship for each class
        grow <- matrix(NA, n.bin, n.bin)      # store growth probabilites for each class
        reproduction <- rep(NA, n.bin)        # store reproduction probabilites for each class
        
        totnums = 0 # this is just monitoring for errors, start at zero before next loop per size subset
        # bin, survival, growth
         for(j in 1:(length(vec.bin)-1)){
          # set limits for size subset according to bin breaks
          bounds <- c(vec.bin[j], vec.bin[j+1])
          # subset data according to bounds
          subset <- df[df$t0 > bounds[1] & df$t0 <= bounds[2],]
          # store number of inviduals in this bin for future reference
          n[j] <- length(subset$t0)
          medians[j] <- median(subset$t0)
          # calculate survivorship for this class
          surv[j] <- sum(subset$survival) / length(subset$t0) # of those alive in year 1, how many survived by bin/size class
          # store histo as object, to access counts per bin
          histo <- hist(subset$t1, breaks = vec.bin, plot = FALSE)
          # $counts returns the number of individuals of a certain size class
          grow[,j] <- histo$counts/length(subset$t0[subset$survival==1]) 
          reproduction[j] <- mean(subset$flowers0*seeds_per_flower, na.rm = TRUE) # seedlings produced per plant in start yr
          
          totnums = totnums + sum(histo$counts)
        }
        
        # make a vector of the prob of seedling sizes: 
        sdlggrow <- hist(allsdszs, breaks = vec.bin, plot = FALSE)$counts/length(allsdszs)
        reproduction[is.nan(reproduction)] <- 0
        
        M1 <- matrix(NA, n.bin, n.bin)   # initiate projection matrix
        M <- matrix(0, (n.bin+1), (n.bin+1))
        # populate projection matrix
      
        for(j in 1:length(surv)){
          M1[,j] <- surv[j] * grow[,j]
          M1[,j] <- (surv[j] * grow[,j])
        }
          
          # add lines for the creation of bulblings and thier transition to first size class
          M[2:(n.bin+1), 2:(n.bin+1)] = M1
          M[2:(n.bin+1),1] = surv_seedlings*sdlggrow 
          M[1,2:(n.bin+1)] = reproduction*seedlings_per_seed  
        
        
        lambdas_matrix[i] <- lambda(M) # calls popbio f'n 'lambda'
        dampratio_matrix[i]=damping.ratio(M)
        lifespan_matrix[i] =lifespan(M)
        
        print(c(i,totnums)) 
      } else {
        lambdas_matrix[i]=NA
        dampratio_matrix[i] = NA
        lifespan_matrix[i] = NA
      }
    }
    list(lambdas_matrix, dampratio_matrix, lifespan_matrix)
}
```

Not by site but across all data, use site, year, and fecundity as a covariate, predict for high and low values 
```{r}
# ScGl
# seedlings_per_seed # not sure if this should be the chance a seed turns into a seedling or something else or how to pick the value
testbins <- c(4,5,6,10,30,50,100) # I don't have enough individuals to get estimates if I break this into too many bins
# df <- size_scgl
# minsize <- minsize_scgl
# maxsize <- maxsize_scgl
# bin.num <- testbins
# allsdszs <- allsdszs_scgl # the distribution of sizes you classify as a seedling
# surv_seedlings <- surv_minis # calculated from using the size class defined as seedlings in time t and the annual surival to t+1; seedling size vs. the smallest bin size which might include more than survival of seedlings

scgl_IPM_all <- IPM_basic(df = size_scgl, seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150, seedling_size = 0.5)

scgl_IPM_all


scgl_IPM_NS <- lapply(unique(size_scgl$Region), function(x){
  IPM_basic(df = size_scgl[size_scgl$Region == x,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150,  seedling_size = 0.5)
  })

sites <- c("Atwell Gulch","Picnic Site","Powerline","Pyramid Rock","T-Junction")
 #unique(size_scgl$Site)
scgl_IPM_sites <- lapply(c("Atwell Gulch","Escalante Canyon","Picnic Site","Pyramid Rock"), function(x){
  print(x)
  IPM_basic(df = size_scgl[size_scgl$Site == x,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins,  seedling_size = 0.5, surv_seedlings = surv_minis, seeds_per_flower = 150)
})

# Errors -Inf
scgl_IPM_Site_year <- lapply(c("Atwell Gulch","Escalante Canyon","Picnic Site","Pyramid Rock"), function(x){
  lapply(unique(size_scgl$year0[size_scgl$Site == x]), function(y){
    print(x);print(y)
  IPM_basic(df = size_scgl[size_scgl$Region == x & size_scgl$year0 == y,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150,  seedling_size = 0.5)
  })
})


scgl_IPM_NS_year <- lapply(unique(size_scgl$Region), function(x){
  lapply(unique(size_scgl$year0[size_scgl$Region == x]), function(y){
    print(x);print(y)
  IPM_basic(df = size_scgl[size_scgl$Region == x & size_scgl$year0 == y,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150,  seedling_size = 0.5)
  })
})


```


```{r}
(lambdas_matrix)
(dampratio_matrix)
(lifespan_matrix)

```

Make a predictive model (as a function only of size in this case) and site, year, and fecundity for each demographic rate: survival, mean growth, variance in growth, prob of reproducing, and how much reproduction if reproducing. The code fits a few alternatives and chooses the best one for each rate, which will be used below. But can't have fecundity in the reproductive ones... ???
```{r}
## Vital rates
# survival
######## ScGl survival #########################
# do it my way 

glm1 <- glm(survival ~ t0, family = "binomial", data = size_scgl)
# glm2 <- glm(survival ~ t0 + t0sq, family = "binomial", data = size_scgl) # don't have a squared term yet, need it?
glm3 <- glm(survival ~ t0 + Site + t0*Site, family = "binomial", data = size_scgl1) # The slope and the intecept could differ
glm4 <- glm(survival ~ t0 + as.factor(year0) + t0*year0, family = "binomial", data = size_scgl1)
glm5 <- glm(survival ~ t0 + as.factor(year0) + t0*as.factor(year0) + Site + t0*Site + as.factor(year0)*Site, family = "binomial", data = size_scgl1)

lm.list <- list(glm1, glm3, glm4, glm5)
lm.names <- as.character(unlist(lapply(lm.list, formula)))
(lm.results <- aictab(lm.list, modnames = lm.names))
# evidence ratio
for(i in 2:length(lm.list)){
  print(exp(0.5*lm.results$Delta_AICc[i]))
}

summary(glm5)

ggplot(size_scgl, aes(t0, survival, colour = Site))+
  geom_point()+
  stat_smooth(method="glm", family=binomial, formula = y~x, aes(fill=Site))+
  facet_grid(cols=vars(year0),
             rows = vars(Site))+
  xlab("Size at time t")+
  ylab("Survival to time t+1")+
  theme_bw()

```


```{r}
# Growth

# growth: non-linear with linear function of size , quadratic function of size, power function (A+B*(size^C))
# nlm1 <- nls(t1 ~ a + b*t0, data = size_scgl, start = list(a=1, b=1))
# nlm2 <- nls(t1 ~ a + b*t0 + c*Site, data=size_scgl, start = (list(a=1, b=1, c=1)))
# nlm3 <- nls(t1 ~ a + b*t0 + c*year0, data=size_scgl, start=list(a=1, b=1, c=1))

glm1 <- glm(t1 ~ t0, family = poisson, data = size_scgl)
nlm.list <- list(nlm1, nlm2, nlm3)
nlm.names <- as.character(unlist(lapply(nlm.list, formula)))
(nlm.results <- aictab(nlm.list, modnames = nlm.names))
for(i in 2:length(nlm.list)){
  print(exp(0.5*nlm.results$Delta_AICc[i]))
}

# getting residuals of growth
size$growth_residuals <- NA
size$growth_residuals[which(!is.na(size$t1) & !is.na(size$t0))] <- summary(bestgrowth)$residuals^2

summary(glm1)

```




