---
title: "Seed Harvest IPM and MPM"
author: "Michelle DePrenger-Levin"
date: "7/26/2020"
output: html_document
---

Example data for Sclerocactus glaucus where size measurements are the width at widest point for these ball cacti
't0' and 't1' are the widths (cm) and survival is for the tagged cactus from year t to t+1. 'reproyesno' is for 't0'. 'flowers0' is a Poisson distribution based on a linear model of number of flowers by size on the one year we took that data. 'minis0' and 'minis1' are the number of seedlings (cacti with < 0.5 cm in width) in year t and t+1
```{r}

rm(list=ls())
library(dplyr)
library(popbio)
library(MuMIn)
library(binr)
library(matrixStats)
require(AICcmodavg)
library(prism)
library(raster)
library(lme4)

setwd("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/")
load("size_scgl.Rda") # data converted to yearly transition
load("allsdszs_scgl.Rda") # only individuals that were < 0.5 and considered seedlings
load("size_scgl1.Rda")
```



# Code adapted from Dan Doak for an IPM

```{r}

seedlings_per_seed <- 10/500 # 0.000001 # the rate that a seed germinates I'm making a wild estimate

# Changed our methods from measuring all individuals to only measuring individuals >= 0.5 cm width in 2012. 
surv_minis1 <- 0.8118812 # from pre-2012 all indiviudals < 0.5 that survived
surv_minis2 <- 0.8157139 # minis1/minis0 using the number of minis associated with a tag at time t+1 accounting for the number of new vegetative individuals (change in number of minis associated with those minis that grew into small vegetative individuals) assuming some die and some new germinants are added but we are unable to measure this
(surv_minis <- mean(c(surv_minis2, surv_minis1)))

# set the minimum size and maximum size
minsize_scgl <- 0.01
maxsize_scgl <- 14.51

```

####################################################
```{r}
lifespan <- function(nx){
  nclasses=dim(nx)[1]
  vec=c(100,rep(0,(nclasses-1)))
  nx[1,]=0
  jj=1
  while (sum(vec)>1){
    vec=nx%*%vec
    jj=jj+1
    #print(sum(vec))
  }
  return(jj)
}
```
#############################################

Size density estimation for median size estimation - for each kernel, the state of an individual at one time that dictates the state and state of any offspring at the next time step (Merow et al. 2014 "Advancing population ecology with integral projeciton models: a practical guide")
```{r}

pdfsz_scgl <- density(size_scgl$t0, n=1024, cut=0, na.rm = TRUE)
pdfsz2_scgl <- cbind(pdfsz_scgl$x,pdfsz_scgl$y)
plot(pdfsz2_scgl, type="l")

```

### Matrix Model 
  Estimate vital rates, populate matrix, for models with different numbers of classes/ bins    

```{r ScGl matrix}
(seed_per_flower <- seedlings_per_seed)

bin.num <- c(4,5,6,7,8) # I don't have enough individuals to get estimates if I break this into too many bins
# ScGl

lambdas_matrix <- rep(NA, length(bin.num))
dampratio_matrix = rep(NA, length(bin.num))
lifespan_matrix=rep(NA, length(bin.num))
mincounts=NULL

for(i in 1:length(bin.num)){
  ss=as.numeric(size_scgl$t0)
  vec.bin = c(minsize_scgl, minsize_scgl+1:bin.num[i]*(maxsize_scgl-minsize_scgl)*(1/bin.num[i]))  # really should split at < 0.6 and then < 2.5 as the non-reproductive sizes, then split above
  # breaks2add <- 2.5+1:(bin.num[i]-1)*(maxsize_scgl-2.1)*(1/(bin.num[i]-1))
  # vec.bin <- c(minsize_scgl, 2.5, breaks2add[1:(bin.num[i]-1)])
  # use vec.bin as the boundaries for size classes
  nums=hist(ss,breaks=vec.bin, plot=FALSE)$counts 
  mincounts=c(mincounts,min(nums))
  
  if (min(nums)>2) {  
    ## Initialize storage
    n.bin <- length(vec.bin)-1                  # this is a workaround
    n <- rep(NA, n.bin)                         # count of indvs per bin
    medians <- rep(NA, n.bin)                    # median size per bin for F
    surv <- rep(NA, n.bin)                      # survivorship for each class
    grow <- matrix(NA, n.bin, n.bin)            # store growth probabilites for each class
    reproduction <- rep(NA, n.bin)
    
    totnums = 0 # this is just monitoring for errors
    # bin, survival, growth  test j<-4
     for(j in 1:(length(vec.bin)-1)){
      # set limits for size subset according to bin breaks
      bounds <- c(vec.bin[j], vec.bin[j+1])
      # subset data according to bounds
      subset <- size_scgl[size_scgl$t0 > bounds[1] & size_scgl$t0 <= bounds[2],]
      # store number of inviduals in this bin for future reference
      n[j] <- length(subset$t0)
      medians[j] <- median(subset$t0)
      # calculate survivorship for this class
      surv[j] <- sum(subset$survival) / length(subset$t0) # of those alive in year 1, how many survived by bin/size class
      # store histo as object, to access counts per bin
      histo <- hist(subset$t1, breaks = vec.bin, plot = FALSE)
      # $counts returns the number of individuals of a certain size class
      grow[,j] <- histo$counts/length(subset$t0[subset$survival==1]) 
      reproduction[j] <- mean(subset$flowers0, na.rm = TRUE) # bulbils produced per plant in start yr - not the same for ScGl, minis aren't produced, not the same as fruit count, which we didn't take or seed count - so estimate how many flower there would likely have been; but there aren't going to be any flowers until >2.5 width
      
      totnums = totnums + sum(histo$counts)
    }
    
    # make a vector of the prob of seedling sizes: 
    sdlggrow <- hist(allsdszs_scgl, breaks = vec.bin, plot = FALSE)$counts/length(allsdszs_scgl)
    reproduction[is.nan(reproduction)] <- 0
    
    M1 <- matrix(NA, n.bin, n.bin)   # initiate projection matrix
    M <- matrix(0, (n.bin+1), (n.bin+1))
    # populate projection matrix
  
    for(j in 1:length(surv)){
      M1[,j] <- surv[j] * grow[,j]
      M1[,j] <- (surv[j] * grow[,j])
    }
      
      # add lines for the creation of bulblings and thier transition to first size class
      M[2:(n.bin+1), 2:(n.bin+1)] = M1
      M[2:(n.bin+1),1] = surv_minis*sdlggrow 
      M[1,2:(n.bin+1)] = reproduction*seed_per_flower  
    
    
    lambdas_matrix[i] <- lambda(M) # calls popbio f'n 'lambda'
    dampratio_matrix[i]=damping.ratio(M)
    lifespan_matrix[i] =lifespan(M)
    
    print(c(i,totnums)) 
  } else {
    lambdas_matrix[i]=NA
    dampratio_matrix[i] = NA
    lifespan_matrix[i] = NA
  }
}
```


```{r}
(lambdas_matrix)
(dampratio_matrix)
(lifespan_matrix)

```

Find best models of climate and size (site...) describing vital rates 
Model uncertainty (see Bakker et al. 2009)  
    
        1. AICc regression models for vital rates
        2. Estimate proportion of process variance not assigned to ecological drivers
        3. Select a model in proportion to its AIC weight
        4. Select model parameters (within distribution of estimate and variance and covariances around estimate)   
        5. Reject parameter sets with unrealistic behavior (if lambda goes haywire)    
        6. Simulate with 100s or 1000s of parameter sets    
        7. for each parameter set, simulate trajectories for scenarios of interest (with starting densities, seed harvest rates)    
        8. Output quasi-extiction probability, pop. growth rates for each different scenario    
        
```{r}
######### ScGl survival #########################
# do it my way 

glm1 <- glm(survival ~ t0, family = "binomial", data = size_scgl1)
glm2 <- glm(survival ~ t0 + t0sq, family = "binomial", data = size_scgl1)
glm3 <- glm(survival ~ t0 + Site + t0*Site, family = "binomial", data = size_scgl1) # The slope and the intecept could differ
glm4 <- glm(survival ~ t0*Site, family = "binomial", data = size_scgl1)

lm.list <- list(glm1, glm2, glm3, glm4)
lm.names <- as.character(unlist(lapply(lm.list, formula)))
(lm.results <- aictab(lm.list, modnames = lm.names))
# evidence ratio
for(i in 2:length(lm.list)){
  print(exp(0.5*lm.results$Delta_AICc[i]))
}

library(lattice)
xyplot(survival ~ t0|Site, size_scgl1,
       type = c("g","p","r"),
       index = function(x,y) coef(lm(y ~ x))[1],
       xlab = "Size at t0",
       ylab = "Survival", aspect = "xy")
################################################
 
ggplot(size_scgl1, aes(t0, survival, colour = Site))+
  geom_point()+
  stat_smooth(se = FALSE)+
  theme_bw()

ggplot(size_scgl1, aes(t0sq, survival))+
  geom_point()+
  stat_smooth(se = FALSE)+
  theme_bw()
```
        

