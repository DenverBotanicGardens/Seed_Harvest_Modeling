---
title: "SeedHarvestSimulations"
author: "Michelle DePrenger-Levin"
date: "9/8/2020"
output: html_document
---

ctrl+Alt+Shift+M == rename in scope
Ran too many print(df) and it busted RStudio
---
title: "Seed Harvest IPM and MPM"
author: "Michelle DePrenger-Levin"
date: "7/26/2020"
output: html_document
---

```{r}

rm(list=ls())
library(dplyr)
library(popbio)
library(MuMIn)
library(binr)
library(matrixStats)
require(AICcmodavg)
library(prism)
library(raster)
library(lme4)
library(ggplot2)
library(patchwork)
# install.packages("roxygen2")

library(stringr)


library(parallel); library(doParallel); library(foreach)

# plot median and variance with ggridges::geom_density_ridges see <https://www.rensvandeschoot.com/tutorials/brms-started/> 
library(ggridges)

# download the Rdata files into your working directory, set your working directory and load them
setwd("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/")
load("size_scgl.Rda") # data converted to yearly transition
load("allsdszs_scgl.Rda") # only individuals that were < 0.5 and considered seedlings
# load("size_scgl1.Rda")

nrow(size_scgl)
names(size_scgl)
```

Store in an R package
```{r}
# I already have a project and a repository
# devtools::create("SeedHarvestModeling")

library(usethis)

# Add R functions
# In project folder, make an integrate.R script to integerate all the functions
usethis::use_vignette("SimulateSeedHarvest")
devtools::document() # to make namespace for each function
```


# Functions     
lifespan to estimate how long lived   
Starts a population of 100 individuals in the seedling or smallest bin; do not start a population in a dormant or seed bank bin  
If you have a matrix where fecundity is measured as seeds entering the seedbank (row 1) and/or seeds germinating (row 2), indicate which rows result in a measure of fecundity 

```{r}

lifespan <- function(nx){
  nclasses=dim(nx)[1]
  vec=c(100,rep(0,(nclasses-1)))
  nx[1,]=0
  jj=1
  while (sum(vec)>1){
    vec=nx%*%vec
    jj=jj+1
  }
  return(jj)
}

# Seeds a population with 100 individuals in the smallest size class, removes the top row (so no more reproduction), and follows the population until all have died. Based on a list of transition matrices (with fecundity rate: Mx, and without fecundity rate included: TMx)
lifespanMPM <- function(Mx, TMx, seedlingBin = 1){
  nclasses=dim(Mx[[1]])[1]
  # add 100 individuals to the smallest non-seedbank category
  vec <- rep(0, nclasses)
  vec[seedlingBin] <- 100
  # remove all fecundity from matrices
  nx <- mapply(function(x,y) x - (x-y), Mx, TMx, SIMPLIFY = FALSE) # keep output as matrices
  # if any transition is 100%
  nx[[1]][nx[[1]] == 1] <- 0.9
  jj=1
  while (sum(vec)>1){
    vec=nx[[sample(1:length(Mx),1)]]%*%(floor(vec)) # randomly sample from the list of matrices with fecundity rate removed
    jj=jj+1
  }
  return(jj)
}


# Generation time in a stage based matrix - Cochran and Ellner 1992; use popbio::generation.time

```


```{r}
AnnualTransition <-function(){
  # above_f <- Mx_list[which(f_all >= mn_f)]  from the SeedHarvestSim function get index of one above 
  # below_f <- Mx_list[which(f_all < mn_f)]   from the SeedHarvestSim function get index of one below
  if(Yr == "Good"){
    Mx_i <- sample(above_f, 1) # randomly sample from the high fecundity transition matrices
  } else {
    Mx_i <- sample(below_f, 1)
  }

  # Freq[] is the likelihood to collect seed in good or bad years
  if(CollectYN == 1){  # yes collect, reduce fecuntity by the year good or bad
    fecundMx <- Mx_list[[Mx_i]] - TMx_list[[Mx_i]] # Subtract the transition matrix (Mx) by the matrix without fecundity rate (TMx) to get only fecundity rate
    fecundMx <- fecundMx - fecundMx*Inten_m[Yr,] # Reduce all fecundity rates by intensity of harvest
    nx <- fecundMx + TMx_list[[Mx_i]] # add the reduced fecundity rates to the transition matrix that lacks the fecundity rate to get new transition matrix
  } else {
      nx <- Mx_list[[Mx_i]]
    }
  K <- 100*StartPopSize  # maximum population size
  if(ddceiling == TRUE & sum(vec[!is.na(Nx_list[[1]])]) >= K*0.9){
    vec.t1 <- floor(nx%*%vec)
    vec <- floor(vec.t1/(lambda(nx))*(1+(lambda(nx)-1)*(1-(sum(vec[!is.na(Nx_list[[1]])])/K ))))  # dominant eigenvalue is lambda and the same as eigen(nx)$values[1]; what now? 1+(lambda(nx)-1) is just lambda(nx)
    } else {
      # Multiply N_t+1 = Matrix*N_t; vec comes from the SeedHarvestSim function
      vec <- floor(nx%*%vec)
    }
  list(vec, lambda(nx), projmat = nx)
}

# starting population of only above ground individuals - pop size is above ground
SeedHarvestSim <- function(Mx_list, TMx_list, Nx, Nx_list, StartPopSize, GoodBadTm, Freq = c(0,0), Int = c(0,0), 
                           TotYrs, ClusteredColl = 1, ddceiling = FALSE){
  # take the distribution of classes (likely the stable stage distribution) and scale to starting population size with integers
  # Scale to starting population size with only the aboveground, detectable stages (no seedbank or dormant); undetectable stages have NA in Nx_list
  Nx_scale <- Nx[!is.na(Nx_list[[1]])]
  # vec <- matrix(floor(Nx*(StartPopSize/sum(Nx))), ncol = 1)
  vec <- matrix(round(Nx*(StartPopSize/sum(Nx_scale)),0), ncol = 1)
  # Annual transition function needs local environment variables
  environment(AnnualTransition) <- environment() 

    # Seed Harvest Rates, frequency, probability of harvest in a given year and intensity or percent of seed harvested
  #     Freq
  #Good X
  #Bad  Y
  # Good vs. bad - either determine the percent per good and bad after given clusters or just keep not in clusters and
  Freq_m <- matrix(Freq, nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Freq")))
  Inten_m <- matrix(Int, nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Inten")))

    # fecundity is the cutoff (practical sense of a good year with lots of seed vs few seed produced) but this doesn't really tell me if there is high production of seed, it's the ratio of recruitment to seed production
  f_all <- apply(mapply(function(x,y) x-y, Mx_list, TMx_list), 2, sum) # subtracting the matrices with fecundity from the matrices with all transitions leaves only the fecundity transitions, adding all remaining fecundity values
  mn_f <- mean(f_all) 
  #The index of above/equal and below average
  above_f <- which(f_all >= mn_f)
  below_f <- which(f_all < mn_f)
  
    # Initialize 
    ceil <- 10*StartPopSize
    Yr <- "Good"
    GBs <- rep(NA,TotYrs)
    Freqs <- rep(NA,TotYrs)
    Intens <- rep(NA,TotYrs)
    PopSize <- rep(NA, TotYrs)
    lambdas <- rep(NA, TotYrs)
    mats <- list()
    yrs <- 1

  # if clustered collection then does not depend on good or bad, will collect during a bad year, all match the larger frequency
  if(ClusteredColl > 1){
    numCollections <- max(Freq)*TotYrs
    numclusters <- floor(numCollections/ClusteredColl) # might underestimate
    i <- 0
    collectionyr_ix <- c()
    notavailable <- c()
    while(i < numclusters){
      available <- setdiff((1:(TotYrs-ClusteredColl)),notavailable) # but need to substract ClusteredColl from each start (clst) 
      clst <- sample(size = 1, x = available) # select from possible non-overlapping starts
      notavailable <- c(notavailable, (clst-ClusteredColl):(clst+ClusteredColl-1))
      collectionyr_ix <- c(collectionyr_ix,c(clst:(clst+ClusteredColl-1)))
      i <- i+1
      if(length(available)<ClusteredColl){
        warning("Cannot find non-overlapping cluster period, set at frequency")
        collectionyr_ix <- c(collectionyr_ix, sample(size = (numCollections-length(collectionyr_ix)), setdiff((1:TotYrs),collectionyr_ix)))
        break
        }
      } # allow adding overlapping cluster periods
    Freqs <- rep(0,TotYrs)
    Freqs[collectionyr_ix] <- 1
    
    while(yrs <= TotYrs){
      # Transition between good and bad years
      Yr <- if(rbinom(1,1,GoodBadTm[Yr,1])==1){
        "Good"
      } else {
          "Bad"
        } # Make next a good or bad year
      
      CollectYN <- Freqs[yrs] # this was in the Annual transition
      onetransition <- AnnualTransition()
      GBs[yrs] <- Yr
      if(CollectYN==1){
        Intens[yrs] <- Inten_m[Yr,]
      }

      PopSize[yrs] <- floor(sum(vec))
      lambdas[yrs] <- onetransition[[2]]
      mats[[yrs]] <- onetransition[[3]]
      yrs <- yrs+1
      }
    } else {
      ######################## Annual Transitions without clusters ######################
      while(yrs <= TotYrs){
        # Transition between good and bad years
        Yr <- if(rbinom(1,1,GoodBadTm[Yr,1])==1){
          "Good"
        } else {
            "Bad"
          } 
        CollectYN <- rbinom(1,1,Freq_m[Yr,]) # this was in the Annual transition
        onetransition <- AnnualTransition()  ### CHECK BACK HERE
        GBs[yrs] <- Yr
        Freqs[yrs] <- CollectYN
        if(CollectYN==1){
          Intens[yrs] <- Inten_m[Yr,]
        }
        
        vec <- onetransition[[1]] 
        PopSize[yrs] <- sum(vec)
        lambdas[yrs] <- onetransition[[2]]
        mats[[yrs]] <- onetransition[[3]]
        yrs <- yrs+1
        }
      } # ends all annual transitions without clusters
    SimDF <- data.frame(GB_yrs = GBs, Frequency = Freqs, Intensity = Intens, PopulationSize = PopSize, Year = 1:TotYrs, 
                        lambdas = lambdas)
    list(SimDF, FreqGB = Freq, IntGB = Int, GBMx = GoodBadTm, StartingPopSize = StartPopSize, Mx = mats,
         LogGrowthRate = stoch.growth.rate(mats, verbose=FALSE)) # $approx is log stochastic growth rate by Tuljapukar's approximation; $sim and CI
}


```


```{r}

# Ellis et al. 2012 paper
tm <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Kaye_transitionmatrices.csv")

sp_info <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Kaye_speciesinfo.csv")

m1 <- gsub("\\[|\\]", "", tm$Mx[100]) 
m2 <- strsplit(m1, ";")  # remove the ";" that separates rows
(m3 <- lapply(m2, function(x) strsplit(trimws(x,"l"), " "))) # split each list element after removing leading whitespace
(m4 <- matrix(as.numeric(unlist(m3)), nrow = length(m3[[1]][[1]]), byrow = TRUE))
# Mx: Annual transition matrix
# Tmx: Annual trnasition matrix with transition probabilities, no fecundity
# Nx: Vector of observed stage structures (counts in each stage); must be at the start

# NA for unobserved stages
Nx_all <- lapply(1:nrow(tm), function(i){
  v1 <- gsub("\\[|\\]", "", tm$Nx[i])
  v2 <- sapply(v1, function(x) strsplit(trimws(x,"l"), " ")) 
  v3 <- as.numeric(unlist(v2[[1]]))
  v3
})

#CIPI get rid of the matrix with different number of stages, do that on its own, most have 3, one population has 6, rename species CIPI3 and CIPI6
Nx_names <- lapply(1:nrow(tm), function(i){
  spp <- tm$SPP[i]
  pop <- tm$POP[i]
  yr <- tm$YR[i]
  paste(spp, pop, yr)
})

# Nx_all[grep("CIPI", unlist(Nx_names))][which(sapply(Nx_all[grep("CIPI", unlist(Nx_names))], function(x) length(x))==3)]

# which(sapply(Nx_all[grep("CIPI", unlist(Nx_names))], function(x) length(x))==3)
# which(sapply(Nx_all[grep("CIPI", unlist(Nx_names))], function(x) length(x))==6)

Nx_names[grep("CIPI", Nx_names)][1:30] <- str_replace_all(Nx_names[grep("CIPI", Nx_names)][1:30], "CIPI", "CIPI3")
Nx_names[grep("CIPI", Nx_names)][31:35] <- str_replace_all(Nx_names[grep("CIPI", Nx_names)][31:35], "CIPI", "CIPI6")

Nx_all[grep("CIPI3", unlist(Nx_names))]
Nx_all[grep("CIPI6", unlist(Nx_names))]

tm$SPP <- as.character(tm$SPP)
tm$SPP[grep("CIPI", tm$SPP)][1:30] <- "CIPI3"
tm$SPP[grep("CIPI", tm$SPP)][31:35] <- "CIPI6"
tm$SPP <- as.factor(tm$SPP)

names(Nx_all) <- Nx_names

# Transitions without fecundity
TMx_all <- sapply(1:nrow(tm), function(i){
  m1 <- gsub("\\[|\\]", "", tm$Tmx[i])
  m2 <- strsplit(m1, ";")  # remove the ";" that separates rows
  m3 <- lapply(m2, function(x) strsplit(trimws(x,"l"), " ")) # split each list element after removing leading whitespace
  m4 <- matrix(as.numeric(unlist(m3)), nrow = length(m3[[1]][[1]]), byrow = TRUE)
  m4
}, simplify =FALSE, USE.NAMES = TRUE)


#CIPI get rid of the matrix with different number of stages, do that on its own, most have 3, one population has 6, rename species CIPI3 and CIPI6
# TMx_all[grep("CIPI", unlist(Nx_names))][which(sapply(TMx_all[grep("CIPI", unlist(Nx_names))], function(x) dim(x))[1,]==3)]
# which(sapply(TMx_all[grep("CIPI", unlist(Nx_names))], function(x) dim(x))[1,]==3)
# which(sapply(TMx_all[grep("CIPI", unlist(Nx_names))], function(x) dim(x))[1,]==6)
# Nx_names[grep("CIPI", Nx_names)][1:30] <- str_replace_all(Nx_names[grep("CIPI", Nx_names)][1:30], "CIPI", "CIPI3")
# Nx_names[grep("CIPI", Nx_names)][31:35] <- str_replace_all(Nx_names[grep("CIPI", Nx_names)][31:35], "CIPI", "CIPI6")
# TMx_all[grep("CIPI3", unlist(Nx_names))]
# TMx_all[grep("CIPI6", unlist(Nx_names))]

names(TMx_all) <- Nx_names

sp_info$SPP <- as.character(sp_info$SPP)
sp_info <- rbind(sp_info, sp_info[sp_info$SPP == "CIPI",])
sp_info$SPP[sp_info$SPP == "CIPI"][1] <- "CIPI3" 
sp_info$SPP[sp_info$SPP == "CIPI"] <- "CIPI6" 


# Transitions and fecundity
Mx_all <- sapply(1:nrow(tm), function(i){
  m1 <- gsub("\\[|\\]", "", tm$Mx[i])
  m2 <- strsplit(m1, ";")  # remove the ";" that separates rows
  m3 <- lapply(m2, function(x) strsplit(trimws(x,"l"), " ")) # split each list element after removing leading whitespace
  m4 <- matrix(as.numeric(unlist(m3)), nrow = length(m3[[1]][[1]]), byrow = TRUE)
  m4
}, simplify =FALSE, USE.NAMES = TRUE)

names(Mx_all) <- Nx_names
Mx_all[grep("CIPI", names(Mx_all))]

lambdas <- sapply(Mx_all, function(x) lambda(x), simplify = FALSE, USE.NAMES = TRUE)

fecundity <- mapply(function(x,y){ 
  fec <- x-y
  rowSums(fec)[1] #Only the first row is funcunity across classes (subtracted out survival by Mx-TMx)
  }, Mx_all, TMx_all)

x <- unique(tm$SPP)[3]

```

To create a generation time function
```{r}
library(matlib)

# Identity matrix
I <- diag(length(Nx_all[[1]]))
# Inverse matrix exists when det(A) != 0
if(det(Mx_all[[1]]) != 0) AI <- inv(Mx_all[[1]])
Mx_all[[1]]
TMx_all[[1]]
AI
# 
eigen(Mx_all[[1]])
# Asymptotic growth rate
lambda(Mx_all[[1]])
# stable stage distribution (w: right eigen vector)
stable.stage(Mx_all[[1]])
# Relative contribution of individuals in each stage to future population growth (v: left eigenvector)
# Arabis fecunda stage 4 reproduces into any of the stage classes, transitions from any size to another
reproductive.value(Mx_all[[1]])


Nx_names[[100]] # Dicerandra frutescens
eigen(Mx_all[[100]])
lambda(Mx_all[[100]])
stable.stage(Mx_all[[100]])
reproductive.value(Mx_all[[100]]) # seedbank, seedlings, small, flowering sm, med fl, large fl
generation.time(Mx_all[[100]])

# Life history traits from stage based matrices; all will differ for different newborn types, none depend on stable stage
# P_x: discrete survivorship function
# expected remaining life-span of an individual in stage i
# mean age at maturity
# f_x: discrete maternity function
# R_o: net reproductive rate

```

```{r}
# how would I expect species to respond to pop size and harvest?   
toplotall <- c()
sp <- "ARFE"
for(w in 1:14){
    Mx <- Mx_all[grep(sp, unlist(Nx_names))][[w]]
    TMx <-  TMx_all[grep(sp, unlist(Nx_names))][[w]]
    # three veg and one repro class, recruits in any class
    print(w)
    print(fecundMx <- Mx - TMx)   
    i <- 0.5
    print(fecundMx <- fecundMx - fecundMx*i)
    print(nx <- fecundMx + TMx);Mx
    print(lambda(nx))
    print(lambda(Mx)) # latter should be larger than prior
}


for(sp in unique(tm$SPP)){
  densityNoharvest <- unlist(lapply(Mx_all[grep(sp, unlist(Nx_names))], function(x) lambda(x)))
  densityHarvest <- do.call(rbind,lapply(seq(0.1,1,by=0.1), function(i){
    densityHarvest <- unlist(mapply(function(Mx, TMx){
      fecundMx <- Mx - TMx # Subtract the transition matrix (Mx) by the matrix without fecundity rate (TMx) to get only fecundity rate
      fecundMx <- fecundMx - fecundMx*i # Reduce all fecundity rates by intensity of harvest
      nx <- fecundMx + TMx # add the reduced fecundity rates to the transition matrix that lacks the fecundity rate to get new transition matrix)))
      lambda(nx)
    }, Mx_all[grep(sp, unlist(Nx_names))], TMx_all[grep(sp, unlist(Nx_names))]))
    data.frame(lambdas = densityHarvest, Intensity = i) 
  }))
  
  addplotall <- rbind(data.frame(SPP = sp, densityHarvest), data.frame(SPP = sp, lambdas = densityNoharvest, Intensity = 0))
  toplotall <- rbind(toplotall, addplotall)
}


ggplot(toplotall[toplotall$SPP == "ARFE",], aes(lambdas, colour = as.factor(Intensity)))+
  geom_density()+
  # geom_histogram(colour = rgb(1,1,1,0.5),position="dodge")+ # scale_fill_hue
  theme_bw()+
  facet_wrap(~SPP, scales = "free")+
  scale_colour_hue(l = 40, c = 80) #, h.start = 10


```



# Matrix Population Models

lambda ~ fecundity
```{r}
load("C:/Users/deprengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/PVA/Paniw etal/patterns_temporal_autocorrelation-master/COMPADRE_v.4.0.0.RData")

# str(compadre[[1]]) # $Ecoregion
# str(compadre[[2]]) # split into 'prop' as seed or undetectable vs. 'active' for above ground, description of each class, number of classes
# str(compadre[[3]]) # each is a list of 4: the matA (average), matU only surivval-dependent demographic processes (seed bank, statis, progression, retrogression, vegetitative dormancy), matF for fecundity, matC (clonal reproduction)

# $ SpeciesAuthor is the taxonomic name from author, and the name from The Plant List $SpeciesAccepted could check $SpeciesAccepted against status

annuals <- compadre[[1]][grep("Annual", compadre[[1]]$OrganismType),]
# write.csv(annuals, file = "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/compadre_annuals.csv")

bofe <- compadre[[1]][grep("Arabis", compadre[[1]]$SpeciesAuthor),c(1:2,5,10,13:15,17:24,27:31,33,35:36,38,41,46:47)]
nrow(bofe)
length(Nx_all[grep("ARFE", unlist(Nx_names))])
sp_info[,c(1:3,13:17)]

AEVI <- compadre$mat[compadre$metadata$Genus == "Aeschynomene"]
# matU is survival matrix
# matF fecundity
# matC clonal

compadre$metadata[compadre$metadata$Genus == "Aeschynomene",]
lapply(AEVI, function(x) x$matA)
AEVI[[1]]$matU + AEVI[[1]]$matF

sp_info[2,]
# sp_info <- rbind(sp_info, c("AEVI","Aeschynomene","virginica","Fabaceae","Ecol Appl 2005",
#                             "Griffith; Forseth","patrick@montgomerybotanical.org","","",1,
#                             "1998-2000",4,"wetland","","annual","herbaceous","semelparous","yes","no",6,2))
# 
# Nx_names <- list(Nx_names, "AEVI AEVI_1", "AEVI AEVI_2", "AEVI AEVI_2")
# Nx_all <- list(Nx_all, c(NA,NA,1,1,1), c(NA,NA,1,1,1), c(NA,NA,1,1,1)) # Don't know but only need which are NA - unobserved seedbank 
# Mx_all <- list(Mx_all, lapply(AEVI, function(x) x$matA))
# TMx_all <- list(TMx_all, lapply(AEVI, function(x) x$matU))

```


```{r}

# Enter plants in first observed stage
seedlingbins <- data.frame(SPP = unique(tm$SPP), 
                           seedlingBin = do.call(rbind,lapply(Nx_all[!duplicated(tm$SPP)], function(x){
                                           if(length(which(is.na(x[1])))==0){
                                             1
                                             } else {
                                               which(is.na(x[1]))+1
                                               }
                             })))

lifelengthsXmatrix <- do.call(rbind,lapply(1:length(Mx_all), function(i){
  data.frame(Lifespan = lifespanMPM(Mx_all[i], TMx_all[i], 
                                    seedlingbins$seedlingBin[seedlingbins$SPP == strsplit(Nx_names[[i]][1]," ")[[1]][1] ]),
             SPP = strsplit(Nx_names[[i]][1]," ")[[1]][1], Site = strsplit(Nx_names[[i]][1]," ")[[1]][2],
             Yr =  strsplit(Nx_names[[i]][1]," ")[[1]][3])
}))

generationtimeXspecies <- do.call(rbind,lapply(sp_info$SPP, function(sp){
  matF <- lapply(1:length(grep(sp, Nx_names)), function(x){ 
    Mx_all[grep(sp, Nx_names)][[x]] - TMx_all[grep(sp, Nx_names)][[x]]
    })
  data.frame(generationTime = generation.time(mean(Mx_all[grep(sp, Nx_names)]),
                                              r = mean(matF)), 
             SPP = sp)
}))

avg.lifespan.sp <- aggregate(Lifespan~SPP,data = lifelengthsXmatrix, median)
sd.lifespan.sp <- aggregate(Lifespan~SPP,data = lifelengthsXmatrix, sd)

lifespan.sp <- cbind(avg.lifespan.sp, SDlifespan = sd.lifespan.sp[,2])
lifespan.sp[order(lifespan.sp$Lifespan),]

lifelengthsXmatrix[lifelengthsXmatrix$SPP == "NEMA",]

lifespan.sp <- merge(lifespan.sp, generationtimeXspecies, by = "SPP")

```


Examples from Ellis et al. 2012    
Arabis fecunda: "Entries in the fecundity matrix were calculated by dividing the number of recruits in a particular stage class by the number of flowering plants the previous year."   Lesica and Shelly 1995 "Demography of Arabis fecunda"
    1. Matrices are labeled 1987 to 1992
    2. Matrix ARFE_Charleys 1987 was measured in 1987 = t and 1988 =t+1 while '1988' is 1988 = t and 1989 = t+1 until 1993 
    3. They estimated seed per fruit for each population each year except 1992
    4. transition probabilities were N_t per class (i) that moved to class (j) over one year N_t+1 divided by the number of plants in class (i) N_t
    5. Reproductive plants can transition among all size classes and seperately can reproduce, these are added in the transition matrix
    6. Recruitment rate = (new recruits in t+1)/(survivors from t); recruits can appear in one or more classes and in any class including reproductive
    7. Number of seed/fruit varied 30.9, 32.4, 34 for Charles Gulch, Lime Gulch, and Vipond Park. Number of fruit per plant varied by year and site

Fecundity alone and then find the number of new recruits? No, can't get that from transition, it is summarized as #new recruits_t+1 / #survivors 
```{r}
TMx_fecundity <- lapply(unique(tm$SPP), function(sp){
  Tx_sp <- TMx_all[grep(sp, unlist(Nx_names))]
  Mx_sp <- Mx_all[grep(sp, unlist(Nx_names))]
  fecundity_sp <- mapply(function(x,y)x-y, Mx_sp, Tx_sp, SIMPLIFY = FALSE)
  fecundity_sp
})


TMx_fecundity[[5]]


```

# save lists to share with CPC group and possible as examples in R package
```{r}
# save(Nx_all, file = "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Nx_all.Rda")
# 
# save(TMx_all, file = "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/TMx_all.Rda")
# 
# save(Mx_all, file = "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Mx_all.Rda")

```


# Fecundity     
Defining a good and bad year as higher than or lower than average fecundity means what for overall growth rate, other life-cycle parameters?     

```{r}
# Is fecundity correlated to lambda
all_summarydata <- data.frame(SPPSiteYr = names(lambdas), SPP = tm$SPP, lmbd = unlist(lambdas), f = unlist(fecundity))
all_summarydata <- merge(all_summarydata, sp_info, by = "SPP")

# for which are fecundity and lambda correlated
lm1 <- lm(lmbd ~ f, data = all_summarydata)
lm2 <- lm(lmbd ~ f * Genus, data = all_summarydata)
lm3 <- lm(lmbd ~ f * Number.of.stages, data = all_summarydata)

lm.list <- list(lm1, lm2, lm3)
lm.names <- as.character(unlist(lapply(lm.list, formula)))
(lm.results <- aictab(lm.list, modnames = lm.names))

# evidence ratio
for(i in 2:length(lm.list)){
  print(exp(0.5*lm.results$Delta_AICc[i]))
}

summary(lm2)

# fecundity doesn't vary for some. 
ggplot(all_summarydata, aes(f, lmbd, colour = Genus))+
  geom_point()+
  stat_smooth(method = "lm")+
  theme_bw()+
  facet_wrap(~Genus, scales="free")+
  theme(legend.position="none")+
  ylab("lambda")+
  xlab("fecundity")
```


# Simulations
## Test output for one species - Dicerandra frutescens (Ellis et al. 2012). Lamiaceae, short lived <10 years (lifespan function estimated 10 years),
iteroparous perennial. Post-fire population had positive growth, 6+ years since fire declining

# start with one species
Arabis fecunda - short lived, no seed bank, no dormancy, fecundity are number of recruits in a stage class by the number of flowering plants the previous year
```{r}

pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Simulation_output/"

# to accomodate annuals and addition species to the Ellis paper
# lifespan is really generation time
SimSimple <- function(HarvestType = "No", sppVector = unique(tm$SPP)[-2], FrG = 0, FrB = 0, intG = 0, intB = 0, 
                      AvgInt = 0, Cgg_gb_bg_bb = c(0.5,0.5,0.5,0.5), reps = 100, Mxs, TMxs, Nxs,
                      Simlength = 50*(floor(lifespan.sp$generationTime[lifespan.sp$SPP==sp])), 
                      lifespan = floor(lifespan.sp$generationTime[lifespan.sp$SPP==sp])){
  lapply(sppVector, function(sp){
    bypopsz <- do.call(rbind,lapply(c(10,50,100,500), function(popsz){
      outdf <- do.call(rbind,lapply(1:reps, function(repNow){
        outSimulation <- SeedHarvestSim(Mx_list = Mxs,
                                        TMx_list = TMxs,
                                        Nx_list = Nxs,
                                        Nx = stable.stage(mean(Mxs)),
                                        StartPopSize = popsz,
                                        GoodBadTm = matrix(Cgg_gb_bg_bb, 
                                                           nrow=2, byrow = TRUE, 
                                                           dimnames = list(c("Good","Bad"),
                                                                           c("Good","Bad"))),
                                        Freq = c(FrG,FrB), Int = c(intG,intB), 
                                        TotYrs = Simlength,
                                        ClusteredColl = 1, # clust,
                                        ddceiling = FALSE)
        # save(outSimulation, file = paste(pathstart,HarvestType,"Harvest_",sp,"PopSz",popsz,"Rep",rep,
        #                                  "Fr",FrG,"_",FrB,"In",intG,"_",intB,"AverageInt",AvgInt,
        #                                  "Climate",paste(Cgg_gb_bg_bb, collapse = "_"),
        #                                  ".Rdata", sep=""))
        # Damping ratio
        AMx <- mean(outSimulation[[6]])
        dampR <- eigen(AMx)$values[1]/abs(eigen(AMx)$values[2])
        
        outSimulation[[1]]$Rep <- repNow
        outSimulation[[1]]$SPP <- sp
        if(any(outSimulation[[1]]$PopulationSize==0)){
          Exterpated <- 1
          Time2Ext <- which(outSimulation[[1]]$PopulationSize == 0)[1]
        } else {
          Exterpated <- 0
          Time2Ext <- NA
        }
        
        # Extinction probability, stochastic lambda, and damping ratio
        out <- data.frame(Tulapprox = outSimulation$LogGrowthRate$approx,
                          LogGrowthSim = outSimulation$LogGrowthRate$sim,
                          Exterpated, Time2Ext, 
                          DampingRatio = as.numeric(dampR),
                          FreqG = FrG, FreqB = FrB, 
                          IntG = intG, IntB = intB,
                          SPP = sp, Clust = 1, StPopSz = popsz, 
                          lifespan = lifespan,
                          Frequency = 0, IntRatio = 0)# Int[1]/Int[2])
        rm(outSimulation)
        out
      })) # end replicates
      outdf
    })) # end bypopsz 
    # bypopsz
    save(bypopsz, file = paste(pathstart, HarvestType,"Harvest",
                               "Fr",FrG,"_",FrB,"In",intG,"_",intB,"AverageInt",AvgInt,
                               "Climate",paste(Cgg_gb_bg_bb, collapse = "_"),sp,
                               ".Rdata", sep=""))
  }) # end species
}

# SimSimple <- function(HarvestType = "No", sppVector = unique(tm$SPP)[-2], FrG = 0, FrB = 0, intG = 0, intB = 0, 
#                       AvgInt = 0, Cgg_gb_bg_bb = c(0.5,0.5,0.5,0.5), reps = 100){
#   lapply(sppVector, function(sp){
#     bypopsz <- do.call(rbind,lapply(c(10,50,100,500), function(popsz){
#       outdf <- do.call(rbind,lapply(1:reps, function(repNow){
#         outSimulation <- SeedHarvestSim(Mx_list = Mx_all[grep(sp, unlist(Nx_names))],
#                                         TMx_list = TMx_all[grep(sp, unlist(Nx_names))],
#                                         Nx_list = Nx_all[grep(sp, unlist(Nx_names))],
#                                         Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
#                                         StartPopSize = popsz,
#                                         GoodBadTm = matrix(Cgg_gb_bg_bb, 
#                                                            nrow=2, byrow = TRUE, 
#                                                            dimnames = list(c("Good","Bad"),
#                                                                            c("Good","Bad"))),
#                                         Freq = c(FrG,FrB), Int = c(intG,intB), 
#                                         TotYrs = 50*(floor(lifespan.sp$generationTime[lifespan.sp$SPP==sp])),
#                                         ClusteredColl = 1, # clust,
#                                         ddceiling = FALSE)
#         # save(outSimulation, file = paste(pathstart,HarvestType,"Harvest_",sp,"PopSz",popsz,"Rep",rep,
#         #                                  "Fr",FrG,"_",FrB,"In",intG,"_",intB,"AverageInt",AvgInt,
#         #                                  "Climate",paste(Cgg_gb_bg_bb, collapse = "_"),
#         #                                  ".Rdata", sep=""))
#         # Damping ratio
#         AMx <- mean(outSimulation[[6]])
#         dampR <- eigen(AMx)$values[1]/abs(eigen(AMx)$values[2])
#         
#         outSimulation[[1]]$Rep <- repNow
#         outSimulation[[1]]$SPP <- sp
#         if(any(outSimulation[[1]]$PopulationSize==0)){
#           Exterpated <- 1
#           Time2Ext <- which(outSimulation[[1]]$PopulationSize == 0)[1]
#           } else {
#             Exterpated <- 0
#             Time2Ext <- NA
#           }
#         
#         # Extinction probability, stochastic lambda, and damping ratio
#         out <- data.frame(Tulapprox = outSimulation$LogGrowthRate$approx,
#                           LogGrowthSim = outSimulation$LogGrowthRate$sim,
#                           
#                           Exterpated, Time2Ext, 
#                           DampingRatio = as.numeric(dampR),
#                           FreqG = FrG, FreqB = FrB, 
#                           IntG = intG, IntB = intB,
#                           SPP = sp, Clust = 1, StPopSz = popsz, 
#                           lifespan = floor(lifespan.sp$generationTime[lifespan.sp$SPP==sp]),
#                           Frequency = 0, IntRatio = 0)# Int[1]/Int[2])
#         rm(outSimulation)
#         out
#         })) # end replicates
#       outdf
#       })) # end bypopsz 
#   # bypopsz
#   save(bypopsz, file = paste(pathstart, HarvestType,"Harvest",
#                              "Fr",FrG,"_",FrB,"In",intG,"_",intB,"AverageInt",AvgInt,
#                              "Climate",paste(Cgg_gb_bg_bb, collapse = "_"),sp,
#                              ".Rdata", sep=""))
#   }) # end species
# }


SimSimple(HarvestType = "No", sppVector = unique(tm$SPP)[1:3], reps = 10)

# load to bind and plot
HarvestType <- "No"
files <- list.files(path = pathstart, pattern = paste(HarvestType, "Harvest", sep=""))
toplot <- do.call(rbind, lapply(files, function(x){
  load(file = paste(pathstart,x,sep = ""))
  bypopsz
  }))


ggplot(toplot, aes(as.factor(StPopSz), DampingRatio))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP)+
  geom_jitter(height=0, width = 0.01)

ggplot(toplot, aes(as.factor(StPopSz), Tulapprox))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP)+
  geom_jitter(height=0, width = 0.01)

ggplot(toplot, aes(as.factor(StPopSz), Time2Ext))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP)+
  geom_jitter(height=0, width = 0.01)

extinctionrisk <- aggregate(Exterpated ~ SPP + StPopSz + FreqG + FreqB + IntG + IntB + generationTime, function(x) sum(x)/length(x) ,data = toplot)

ggplot(extinctionrisk, aes(lifespan, Exterpated))+
  stat_smooth(method = 'lm')+
  theme_bw()+
  facet_wrap(~as.factor(StPopSz))+
  geom_point()

```

# seed collection only in good years
```{r}

pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Simulation_output/"

# ONly got through GEPN for Freq 0.2, Int 0.2. Might need to do fewer

#Intensity of 0.1 to 1; Frequency 0.1 to 0.9: wouldn't ever do 100 of seed 100 of the time
lapply(seq(0.1,1, by = 0.1), function(intG){
  lapply(seq(0.1,1, by = 0.1), function(FrG){
  SimSimple(HarvestType = "GoodYrOnly", sppVector = unique(tm$SPP), intG = intG, FrG = FrG )
  })
  })

```


Equal harvest

Unequal harvest

# Figures 
```{r}

pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Simulation_output/"

# load to bind and plot
HarvestType <- "GoodYrOnly"
# HarvestType <- "BiasAvg"
toplot <- do.call(rbind, lapply(unique(tm$SPP), function(sp){
  files <- list.files(path = pathstart, pattern = paste(HarvestType, "Harvest", sp, sep=""))
  out <- do.call(rbind, lapply(files, function(x){
    load(file = paste(pathstart,x,sep = ""))
    bypopsz
  }))
}))

# Bias Intensity, Frequency same
# sometimes zero
toplot$gbIntBias <- (toplot$IntG+0.00001)/(toplot$IntB+0.00001)
ggplot(toplot, aes(gbIntBias, DampingRatio, colour = as.factor(StPopSz)))+
  theme_bw()+
  facet_wrap(~SPP)+
  geom_point()+
  stat_smooth()

ggplot(toplot, aes(gbIntBias, Tulapprox, colour = as.factor(StPopSz)))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP)

ggplot(toplot[!is.na(toplot$Time2Ext),], aes(as.factor(StPopSz), Time2Ext, colour = as.factor(FreqG)))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP)

extinctionrisk <- aggregate(Exterpated ~ SPP + StPopSz + FreqG + FreqB + IntG + IntB + generationTime, function(x) sum(x)/length(x) ,data = toplot)

ggplot(extinctionrisk, aes(lifespan, Exterpated, colour = as.factor(FreqG)))+
  stat_smooth(method = 'lm')+
  theme_bw()+
  facet_wrap(~as.factor(StPopSz))
geom_point()

# GoodYrOnly
table(toplot$FreqG, toplot$IntG)
ggplot(toplot, aes(as.factor(StPopSz), DampingRatio, colour = as.factor(FreqG)))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP, scales = "free")
  #+
  # geom_jitter(height=0, width = 0.01)

ggplot(toplot, aes(as.factor(StPopSz), Tulapprox, colour = as.factor(FreqG), fill = as.factor(IntG)))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP, scales = "free")

toplot$gFreq2Int <- toplot$FreqG/toplot$IntG

ggplot(toplot, aes(as.factor(gFreq2Int), Tulapprox, colour = as.factor(StPopSz)))+
  # geom_boxplot()+
  theme_bw()+
  geom_point()+
  geom_smooth()+
  facet_wrap(~SPP, scales = "free")+
  geom_jitter(height = 0, width = 0.1)

ggplot(toplot[!is.na(toplot$Time2Ext),], aes(as.factor(StPopSz), Time2Ext, colour = as.factor(FreqG)))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP)

extinctionrisk <- aggregate(Exterpated ~ SPP + StPopSz + FreqG + FreqB + IntG + IntB + lifespan, function(x) sum(x)/length(x) ,data = toplot)

ggplot(extinctionrisk, aes(lifespan, Exterpated, colour = as.factor(FreqG)))+
  stat_smooth(method = 'lm')+
  theme_bw()+
  facet_wrap(~as.factor(StPopSz))
geom_point()

```



Stochastic lambda
1. Tuljapurkar's approximation method and 
2. simulation-based projection over many time steps
Dan Doak: geometric mean = prod(lambdas)^(1/years) or (vector(_t+n)/sum(start vector))^1/n
```{r}

sp <- "TRGR"
# All lambdas per matrix
x <- sapply(Mx_all[grep(sp, unlist(Nx_names))], lambda)

stchgr <- stoch.growth.rate(Mx_all[grep(sp, unlist(Nx_names))], maxt = 100)
log(prod(sample(x, 100, replace = TRUE))^(1/100))
log(mean(sample(x, 100, replace = TRUE)))
# back transformed Tuljapukar's approximation
exp(stchgr$approx)
# stochastic from simulation
exp(stchgr$sim)
exp(stchgr$sim.CI)

# arithmetic mean
mean(x)
# geometric mean
exp(mean(log(x)))
prod(x)^(1/length(x)) # Same!!
# asymptotic lambda for the mean matrix
lambda(mean(Mx_all[grep(sp, unlist(Nx_names))]))
mean(x)

x <- matrix(x, )

```


```{r}

popsz <- c(10,50,100,500)
# sp <- "SIAC" # "ASSC"
# sp <- "ASSC"
sp <- "HYCU"

  # resultpathNoharvest <- list.files(path = pathstart, 
  #                          pattern = paste("NoHarvestlistoflists", sp, sep=""), # _ARFEPopulationStart",
  #                          full.names = TRUE)
  resultpathharvest <- list.files(path = pathstart, 
                           pattern = paste("listoflistsTotYrs100",sp,"DDFALSE", sep=""),
                           full.names = TRUE)
  
  toplotall <- do.call(rbind,lapply(resultpathharvest, function(xfile){
    load(xfile)
    toplotall <- do.call(rbind,lapply(1:4, function(i){
      freqSameInt <- strsplit(xfile, "Freq")[[1]][2]
      FreqN <- strsplit(freqSameInt, "SameInt")[[1]][1]
      IntN <- strsplit(freqSameInt, "SameInt")[[1]][2]
      toplot <- do.call(rbind, lapply(bypopsz[[i]], function(x){
        x[[2]]
        x[[2]]$PopStart <- popsz[i]
        x[[2]]$Freq <- FreqN
        x[[2]]$Int <- IntN
        x[[2]]
        }))
    }))
    }))
# head(bypopsz[[1]][[2]])
# head(toplotall)
  
  summary_time2ext <- do.call(rbind,lapply(resultpathharvest, function(xfile){
    load(xfile)
    toplotall <- do.call(rbind,lapply(1:4, function(i){
      freqSameInt <- strsplit(xfile, "Freq")[[1]][2]
      FreqN <- strsplit(freqSameInt, "SameInt")[[1]][1]
      IntN <- strsplit(freqSameInt, "SameInt")[[1]][2]
      toplot <- do.call(rbind, lapply(bypopsz[[i]], function(x){
        data.frame(PopulationStart = popsz[i], Freq=FreqN, 
                   Int = IntN, Time2Ext = x[[2]][which(x[[2]]$PopulationSize == 0)[1],],
                   x[[1]])
        }))
      data.frame(toplot, ExtinctionRisk = sum(toplot$Exterpated)/100)
    }))
    }))
  
  
  #[summary_time2ext$PopulationStart < 500,]
  
  
ggplot(summary_time2ext, aes(Freq, Time2Ext.Year, fill = as.factor(Int)))+
  geom_boxplot()+
  facet_wrap(~PopulationStart,scales = "free", nrow = 3)+
  theme_bw()+
   guides(fill=guide_legend(title= "Harvest\nIntensity"))+
   # scale_colour_discrete(guide = 'none')+
   ylab("Years to Extinction")+
   xlab("Harvest Frequency")+
   labs(title = paste(sp_info$Genus[sp_info$SPP == sp], sp_info$Species[sp_info$SPP == sp]))
      
 ggplot(toplotall[toplotall$Year==30 & toplotall$PopStart > 50,], aes(Freq, PopulationSize, fill = as.factor(Int)))+
   geom_boxplot()+
   # geom_jitter(aes( colour= as.factor(Int)), alpha =0.3, size = 0.5, height = 0)+
   facet_wrap(~PopStart, scales = "free", nrow = 2)+
   theme_bw()+
   guides(fill=guide_legend(title= "Harvest\nIntensity"))+
   scale_colour_discrete(guide = 'none')+
   ylab("Population size at year 30")+
   xlab("Harvest Frequency")+
   labs(title = paste(sp_info$Genus[sp_info$SPP == sp], sp_info$Species[sp_info$SPP == sp]))
   
 #  & toplotall$PopStart > 100 &
                    toplotall$Int %in% c(0,0.3,0.4,0.5)
 ggplot(toplotall[toplotall$Year==30,], aes(Freq, PopulationSize, fill = as.factor(Int)))+
   geom_boxplot()+
   # geom_jitter(aes( colour= as.factor(Int)), alpha =0.3, size = 0.5, height = 0)+
   facet_wrap(~PopStart, scales = "free", nrow = 2)+
   theme_bw()+
   guides(fill=guide_legend(title= "Harvest\nIntensity"))+
   scale_colour_discrete(guide = 'none')+
   ylab("Population size at year 100")+
   xlab("Harvest Frequency")+
   labs(title = paste(sp_info$Genus[sp_info$SPP == sp], sp_info$Species[sp_info$SPP == sp]))
   
```

```{r}
summarytoplotall <- do.call(rbind,lapply(resultpathharvest, function(xfile){
    load(xfile)
    toplotall <- do.call(rbind,lapply(1:4, function(i){
      toplot <- do.call(rbind, lapply(bypopsz[[i]], function(x){ 
        freqSameInt <- strsplit(xfile, "Freq")[[1]][2]
        FreqN <- strsplit(freqSameInt, "SameInt")[[1]][1]
        IntN <- strsplit(freqSameInt, "SameInt")[[1]][2]

        x[[1]]
        x[[1]]$PopStart <- popsz[i]
        x[[1]]$Freq <- FreqN
        x[[1]]$Int <- IntN
        x[[1]]
        }))
    }))
    })) 

# bypopsz[[1]]

# head(summarytoplotall)
# head(sumsumtoplot)
# table(summarytoplotall$Freq, summarytoplotall$Int)

sumsumtoplot <- aggregate(Tulapprox ~ Freq + Int +PopStart, mean, data = summarytoplotall)
nrow(sumsumtoplot) # length 51
length(seq(0.1,0.5,by=0.1))+length(seq(0.1,1,by=0.1))+1 # should be 16. What else do I got in here? 
length(resultpathharvest)


ggplot(sumsumtoplot, aes(Freq, Tulapprox, colour = as.factor(Int)))+
  geom_point()+
  # geom_line()+
  facet_wrap(~PopStart, scales = "free")+
  theme_bw()+
  labs(colour = "Harvest\nIntensity")+
  ylab("Tuljapukar's approximation (log stochastic growth rate)")+
  xlab("Harvest Frequency")+
   labs(title = paste(sp_info$Genus[sp_info$SPP == sp], sp_info$Species[sp_info$SPP == sp]))


ggplot(summarytoplotall, aes(Freq, Tulapprox, colour = as.factor(Int)))+ #,fill = as.factor(Int)
  geom_boxplot(position = "dodge")+  
  geom_point(data=sumsumtoplot, mapping =  aes(Freq, Tulapprox), colour = "black",size = 0.5)+
  # geom_jitter(aes( colour= as.factor(Int)), alpha =0.3, size = 0.5, height = 0)+
  facet_wrap(~PopStart, scales = "free")+
  theme_bw()+
  guides(fill=guide_legend(title= "Harvest\nIntensity"))+
  scale_colour_discrete(guide = 'none')+
  ylab("Tuljapukar's approximation (log stochastic growth rate)")+
  xlab("Harvest Frequency")+
   labs(title = paste(sp_info$Genus[sp_info$SPP == sp], sp_info$Species[sp_info$SPP == sp]))

ggplot(summarytoplotall[summarytoplotall$Int %in% c(0,0.3,0.4,0.5),], aes(Freq, Tulapprox, colour = as.factor(Int),fill = as.factor(Int)))+
  geom_boxplot(position = "dodge2")+  
  geom_jitter(aes( colour= as.factor(Int)), alpha =0.3, size = 0.5, height = 0)+
  facet_wrap(~PopStart, scales = "free")+
  theme_bw()+
  guides(fill=guide_legend(title= "Harvest\nIntensity"))+
  scale_colour_discrete(guide = 'none')+
  ylab("Tuljapukar's approximation (log stochastic growth rate)")+
  xlab("Harvest Frequency")+
   labs(title = paste(sp_info$Genus[sp_info$SPP == sp], sp_info$Species[sp_info$SPP == sp]))
  
```

```{r}
resultpathharvest <- list.files(path = pathstart, 
                         pattern = "DDFALSE",
                         full.names = TRUE)

summary_time2ext <- do.call(rbind,lapply(resultpathharvest, function(xfile){
  load(xfile)
  toplotall <- do.call(rbind,lapply(1:4, function(i){
    freqSameInt <- strsplit(xfile, "Freq")[[1]][2]
    FreqN <- strsplit(freqSameInt, "SameInt")[[1]][1]
    IntN <- strsplit(freqSameInt, "SameInt")[[1]][2]
    toplot <- do.call(rbind, lapply(bypopsz[[i]], function(x){
      data.frame(PopulationStart = popsz[i], Freq=FreqN, 
                 Int = IntN, Time2Ext = x[[2]][which(x[[2]]$PopulationSize == 0)[1],],
                 x[[1]])
      }))
    data.frame(toplot, ExtinctionRisk = sum(toplot$Exterpated)/100)
  }))
  }))

# PCA (or really rda: redundancy analysis) for growth rate, time to extinction, lifespan, extinction risk, frequency, intentisty (eventually IntRatio, cluster), could do Family, Biome, iteroparous 
library(vegan)

require(AICcmodavg)
require(lme4)

allSPP <- merge(summary_time2ext, sp_info, by.x = "Time2Ext.SPP", by.y = "SPP")
allSPP <- merge(allSPP, lifespan.sp, by = "SPP")
names(allSPP)
table(allSPP$SPP, allSPP$Int)

# Lifespan isn't exactly fair since same per genus but is a continous instead of a discrete variable
lm1 <- lm(Tulapprox ~ Freq*Int, data = allSPP)
lm2 <- lm(Tulapprox ~ Freq + Int + lifespan, data = allSPP)
lm3 <- lm(Tulapprox ~ Freq + Int, data = allSPP)
lm4 <-lm(Tulapprox ~ Freq, data = allSPP)
lm5 <-lm(Tulapprox ~ Int, data = allSPP) 
lm6 <-lm(Tulapprox ~ Freq + lifespan, data = allSPP)
lm7 <-lm(Tulapprox ~ Int + lifespan, data = allSPP) 

formulas <- list(lm1,lm2,lm3, lm4, lm5, lm6, lm7)
(lmresults <- aictab(formulas,
       modnames=as.character(unlist(lapply(formulas,formula)))))
evidence(aictab(cand.set = formulas,
                modnames = as.character(unlist(lapply(formulas,formula)))))


```
Check density dependence and see what get sto what we have in the field. Test different scenarios and which best approximates reality. Only add density dependence on the ones that do have exponential growth. Or by patterns - by functional group and how does it differ by group by trees or astragalus 
Maybe should have harvest with a break every X years instead of harvest for some years in a row


No harvest to compare   
```{r}

cores <- detectCores()-1
pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Simulation_output/"

lapply(unique(tm$SPP)[-2], function(sp){ # [-2]CIPI has one population with different number of stages
  lapply(0, function(FrG){  # seq(0.1,0.4,by=0.1)
    lapply(c(10, 50, 100, 500), function(popsz){ # commondeering for population size # c(1,3,5), function(clust)
      lapply(0, function(avgInt){ # seq(0.1,1,by=0.1)
                # intB <- round(runif(1, min = 0, max = min((2*avgInt),1)),2); intG <- 2*avgInt - intB; if(intG>1) intG <- 1
                      cl <- makeCluster(cores)
                      registerDoParallel(cl)
                      out <- foreach(x = 1:500, .packages = c("popbio"),
                                     .export = c(ls(globalenv()),"FrG","sp","popsz"), # ,"clust"),
                                     # .combine = "c", .multicombine = FALSE) %dopar% {
                                     .combine = "rbind") %dopar% {
                                       test_SPP <- SeedHarvestSim(Mx_list = Mx_all[grep(sp, unlist(Nx_names))], 
                                                                  TMx_list = TMx_all[grep(sp, unlist(Nx_names))],
                                                                   Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
                                                                   StartPopSize = popsz, # 100,
                                                                   GoodBadTm = matrix(c(0.5,0.5,0.5,0.5), 
                                                                                      nrow=2, byrow = TRUE, 
                                                                                      dimnames = list(c("Good","Bad"), c("Good","Bad"))),
                                                                   Freq = c(0,0), # c(FrG,0),
                                                                   Int = c(0,0), # c(intG,intB),
                                                                   TotYrs = 50*(floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp])),
                                                                   ClusteredColl = 1, # clust,
                                                                   ddceiling = TRUE)
                                          test_SPP[[1]]$Rep <- x
                                          Exterpated <- if(any(test_SPP[[1]]$PopulationSize==0)){
                                            1
                                          } else {
                                            0
                                            
                                          } 
                                          out <- data.frame(Tulapprox = test_SPP$LogGrowthRate$approx, Exterpated, Rep = x, FreqG = Freq[1],
                                                            FreqB = Freq[2], IntG = 0, #intG, 
                                                            IntB = 0, # intB,
                                                            SPP = sp, Clust = 1, # clust,
                                                            Frequency = FrG, IntRatio = 0)# Int[1]/Int[2])
                                          # list(out, test_SPP[[1]])
                                          out
                                     }
                                  on.exit(stopCluster(cl))
                                  #  save(out, file = paste(pathstart,"Harvest_",sp,"Cluster",clust,"AvgInt",avgInt,"Freq",FrG,".Rdata", sep="")) # got through HARA on this
                                  save(out, file = paste(pathstart,"NoHarvest_",sp,"PopulationStart",popsz,"AvgInt",avgInt,"Freq",FrG,".Rdata", sep=""))
                                  
                                  }) # End across avg intensity
      }) # End across cluster size
    }) # End across Frequency
  })
```




####################################################################
# Periodicity
Continuous intensity keeping frequency consistent and cluster consistent; scale years for simulation by lifespan    
1. Does having different good to bad change the resulting time to extinction or end size (all else 10%)     
          if yes:   
             2. Does having collections in consecutive years instead of randomly over time change results?
                 if yes: 
                    3. Does allowing intensity between good and bad years to vary change outcomes?
```{r}
#ARFE gets so big and starts to be NaN for pop size. Exponential growth

allsims <- lapply(unique(tm$SPP)[-2], function(sp){ # [-2]CIPI has one population with different number of stages
  # for(GB in 1:4){
    startszout <- lapply(1:4, function(popsz){
      clusterout <- lapply(1:3, function(csz){ # clustered collection number of years
        FreqRates <- cbind(rbind(.1,.1))
        i <- c(.1,.1) # Change to cbind of more later, and add random selection later
        totyr <- 50*(floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp])) # make it 100*lifespan
        startpop <- c(10,100,500,1500)
        clucol <- c(1,3,5)
        rep_gb <- 100
        
        noANDharvest <- do.call(rbind,lapply(1:rep_gb, function(gbreps){# Replicates of different good bad transitions
            gbtrG2G <- round(runif(1, min = 0, max = 1),2); gbtrB2G <- round(runif(1, min = 0, max = 1),2)
            gbRANDOM <- matrix(c(gbtrG2G,(1-gbtrG2G),gbtrB2G,(1-gbtrB2G)), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad")))
            # gbNOCOR <- c(0.5,0.5,0.5,0.5)
            # difffromNOCOR <- dist(rbind(as.vector(gbRANDOM), gbNOCOR)) # Euclidean distance 
            clusterGB <- gbRANDOM[1,1]-gbRANDOM[2,2]
            # Check progress
            print(paste("Replicate",gbreps,"for species:",sp))
              noharvest <- do.call(rbind, lapply(1:100, function(x){ # replicates
                out_rep <- SeedHarvestSim(Mx_list = Mx_all[grep(sp, unlist(Nx_names))], 
                                          TMx_list = TMx_all[grep(sp, unlist(Nx_names))],
                                          Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
                                          StartPopSize = startpop[popsz],
                                          # GoodBadTm = GBmatrix[[GB]], # When cycling over distinct rates if found to make a difference
                                          GoodBadTm = gbRANDOM,
                                          Freq = c(0,0),
                                          Int = c(0,0),
                                          TotYrs = totyr,
                                          ClusteredColl = clucol[csz])
  
                out_n <- data.frame(SPP = sp, EndPopSz = out_rep[[1]]$PopulationSize[nrow(out_rep[[1]])],  # End population size
                    Replicate = x,GoodFreq = 0,BadFreq = 0,GoodInt = 0, BadInt = 0, 
                    Harvest = paste(0, 0, 0, 0, sep=":"),
                    GB_mat = paste(as.vector(gbRANDOM), collapse = ":"),
                    DiffGB_mat = clusterGB, Lifespan = floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp]), 
                    # Time to extinction: the first year the population falls below 1; when never met which.max returns 1
                    Yr2Ext = which(out_rep[[1]]$PopulationSize<1)[1], 
                    lifespan = floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp]),
                    CollectionYrs <- clucol[csz],
                    StartPopSize = startpop[popsz])
                out_n
                })) # end no harvest
              harvestfreq.int <- do.call(rbind,apply(FreqRates, 2, function(f){
              nowharvest <- do.call(rbind,lapply(1:1, function(x){ # without parallel; replicates of frequency
                Intout <- do.call(rbind,lapply(1:100, function(irep){ # make 1:1000 after it works, selecting new intensities
                  # i <- c(runif(1, min = 0, max = 1),runif(1, min = 0, max = 1)) # 1000 replicates of random selection of a good and bad intensity
                  # i1 <- runif(1, min = 0, max = 1)
                  # i <- c(i1,i1)
                  out_rep <- SeedHarvestSim(Mx_list = Mx_all[grep(sp, unlist(Nx_names))],
                                            TMx_list = TMx_all[grep(sp, unlist(Nx_names))],
                                            Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
                                            StartPopSize = startpop[popsz],
                                            GoodBadTm =gbRANDOM,
                                            Freq = c(f[1],f[2]),
                                            Int = c(i[1],i[2]),
                                            TotYrs = totyr,
                                            ClusteredColl = clucol[csz])
  
                out_n <- data.frame(SPP = sp, EndPopSz = out_rep[[1]]$PopulationSize[nrow(out_rep[[1]])],  # End population size
                    Replicate = x,GoodFreq = f[1],BadFreq = f[2],GoodInt = i[1], BadInt = i[2], 
                    Harvest = paste(f[1], f[2], i[1], i[2], sep=":"),
                    GB_mat = paste(as.vector(gbRANDOM), collapse = ":"),
                    DiffGB_mat = clusterGB, Lifespan = floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp]), 
                    # Time to extinction: the first year the population falls below 1; when never met which.max returns 1
                    Yr2Ext = which(out_rep[[1]]$PopulationSize<1)[1], 
                    lifespan = floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp]),
                    CollectionYrs <- clucol[csz],
                    StartPopSize = startpop[popsz])
                out_n
                  }))
                Intout
                }))
              nowharvest
              })) # end harvestfreq.int apply and rbind
              ynharvest <- rbind(noharvest, harvestfreq.int)
              ynharvest
              })) # loop for different GB matrices
        save(noANDharvest, file = paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/noANDharvest",
                                        sp,"popsz",startpop[popsz],"clustersz",clucol[csz],"reps",rep_gb,".Rdata",sep=""))
          noANDharvest
          }) # lapply for how many years of collections
      clusterout
      }) # loop for population starting sizes
    startszout
    }) # loop for all species


```




Read in saved individual simulations, make figures
```{r}
pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/"
startpop <- c(10,100,500,1500)
clucol <- c(1,3,5)

# test
# s <- startpop[1]
# cl <- clucol[1]
# x <- resultpath[2]
# harv <- harvestlevels[2]
# GB <- unique(noANDharvest$GB_mat)[1]
# rm(s);rm(cl);rm(x);rm(harv);rm(GB)

harvestsims <- lapply(startpop, function(s){
  clusters <- lapply(clucol, function(cl){
    resultpath <- list.files(path = pathstart, 
                             pattern = paste("popsz",s,"clustersz",cl,"reps100",sep=""), 
                             full.names=TRUE)
    dfs <- do.call(rbind,lapply(resultpath[-1], function(x){
      load(x) # loads a noANDharvest simulation for a species/clustersize/popsize/variableGBs
      
      harvestlevels <- levels(factor(noANDharvest$Harvest))
      diff.time2ext <- do.call(rbind,lapply(harvestlevels[harvestlevels!="0:0:0:0"] ,function(harv){ # how many columns of frequency and intensity rates
          
          diff.GBmats <- do.call(rbind, lapply(unique(noANDharvest$GB_mat), function(GB){
            if(any(!is.na(noANDharvest$Yr2Ext[noANDharvest$Harvest=="0:0:0:0" & noANDharvest$GB_mat == GB])) &
               any(!is.na(noANDharvest$Yr2Ext[noANDharvest$Harvest==harv & noANDharvest$GB_mat == GB]))){ # Does the population eventually go to extinction at this GB matrix?
              diff.Yr2Ex <- do.call(rbind,lapply(1:100, function(reps){
                # eventually check across levels of harvest, now is levels of good to bad
                noharvest <- noANDharvest[noANDharvest$Harvest=="0:0:0:0" & !is.na(noANDharvest$Yr2Ext) & noANDharvest$GB_mat == GB,] 
                harvest <- noANDharvest[noANDharvest$Harvest==harv & !is.na(noANDharvest$Yr2Ext) & noANDharvest$GB_mat == GB,]
                har_idx <- sample(1:nrow(harvest), size = 1)
                out <- data.frame(DiffTime2Ext = harvest$Yr2Ext[har_idx]/sample(noharvest$Yr2Ext, size = 1), #(sample(noharvest$Yr2Ext, size = 1)-(harvest$Yr2Ext[har_idx])), 
                                  GB_matrix = harvest$GB_mat[har_idx], DistGB = harvest$DiffGB_mat[har_idx],
                                  Harvest = harv, lifespan = unique(noANDharvest$lifespan), SPP = unique(noANDharvest$SPP),
                                  StartPopSz = s, CollClu = cl)
                out
              }))
              diff.Yr2Ex
              } # end if statement
            })) # all in list of different frequency rates
          diff.GBmats
          })) # end GB levels
        diff.time2ext
      }))
    dfs
    }) # clusters
  clusters
  }) # pop sizes

table(harvestsims[[1]][[2]]$StartPopSz,harvestsims[[1]][[2]]$CollClu)

# get error for very large numbers with EndPopSz
for(i in 1:4){ # for the starting population sizes (now should be 4 but this has three, missing starting with 10)
  for(j in 1:3){ # each sub-list has three, 1, 3, and 5 consecutive years of collections
    ggsave(filename = paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/","StartPopSz",unique(harvestsims[[i]][[j]]$StartPopSz),
                            "ClusterCol", unique(harvestsims[[i]][[j]]$CollClu),"_time2ext.jpg",sep=""),
           ggplot(harvestsims[[i]][[j]], aes(DistGB, DiffTime2Ext, colour = as.factor(lifespan)))+
             # geom_point(size=0.25, alpha=0.25)+
             stat_smooth(method = "lm", formula = y ~ x + I(x^2),se = FALSE)+ #method = "loess"
             theme_bw()+
             scale_color_discrete(name="Lifespan")+             
             labs(title = str_wrap(paste("Difference in years to extinction at harvest level: ",unique(harvestsims[[i]][[j]]$Harvest), 
                                         ", starting population size ",unique(harvestsims[[i]][[j]]$StartPopSz), 
                                         ", and clusters of ", unique(harvestsims[[i]][[j]]$CollClu), 
                                         " consecutive years of collection.", sep=""), width = 70),
                  x = "Periodicity",
                  y = "Time to exctinction as a percent of no harvest"),
           width=300, height=300,units='mm', dpi=300)
  }
}

    
```


```{r}

pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/"
startpop <- c(10,100,500,1500)
clucol <- c(1,3,5)

# test
s <- startpop[1]
cl <- clucol[1]
x <- resultpath[2]
harv <- harvestlevels[2]
GB <- unique(noANDharvest$GB_mat)[1]
rm(s);rm(cl);rm(x);rm(harv);rm(GB)

harvestsims_endpop <- lapply(startpop, function(s){
  clusters <- lapply(clucol, function(cl){
    resultpath <- list.files(path = pathstart, 
                             pattern = paste("popsz",s,"clustersz",cl,"reps100",sep=""), 
                             full.names=TRUE)
    dfs <- do.call(rbind,lapply(resultpath[-1], function(x){
      load(x) # loads a noANDharvest simulation for a species/clustersize/popsize/variableGBs
      
      harvestlevels <- levels(factor(noANDharvest$Harvest))
      diff.time2ext <- do.call(rbind,lapply(harvestlevels[harvestlevels!="0:0:0:0"] ,function(harv){ # how many columns of frequency and intensity rates
          
          diff.GBmats <- do.call(rbind, lapply(unique(noANDharvest$GB_mat), function(GB){
            if(any(!is.na(noANDharvest$EndPopSz[noANDharvest$Harvest=="0:0:0:0" & noANDharvest$GB_mat == GB])) &
               any(!is.na(noANDharvest$EndPopSz[noANDharvest$Harvest==harv & noANDharvest$GB_mat == GB]))){ # Does the population not go extinct at this GB matrix?
              diff.Yr2Ex <- do.call(rbind,lapply(1:2, function(reps){
                # eventually check across levels of harvest, now is levels of good to bad
                noharvest <- noANDharvest[noANDharvest$Harvest=="0:0:0:0" & !is.na(noANDharvest$EndPopSz) & noANDharvest$GB_mat == GB,] 
                harvest <- noANDharvest[noANDharvest$Harvest==harv & !is.na(noANDharvest$EndPopSz) & noANDharvest$GB_mat == GB,]
                har_idx <- sample(1:nrow(harvest), size = 1)
                out <- data.frame(DiffEndPopsz =  (log(harvest$EndPopSz[har_idx]))/(log(sample(noharvest$EndPopSz, size = 1))),
                                  GB_matrix = harvest$GB_mat[har_idx], DistGB = harvest$DiffGB_mat[har_idx],
                                  Harvest = harv, lifespan = unique(noANDharvest$lifespan), SPP = unique(noANDharvest$SPP),
                                  StartPopSz = s, CollClu = cl)
                out
              }))
              diff.Yr2Ex
              } # end if statement
            })) # all in list of different frequency rates
          diff.GBmats
          })) # end GB levels
        diff.time2ext
      }))
    dfs
    }) # clusters
  clusters
  }) # pop sizes

table(harvestsims_endpop[[1]][[2]]$StartPopSz,harvestsims_endpop[[1]][[2]]$CollClu)

# get error for very large numbers with EndPopSz
for(i in 1:4){ # for the starting population sizes (now should be 4 but this has three, missing starting with 10)
  for(j in 1:3){ # each sub-list has three, 1, 3, and 5 consecutive years of collections
    ggsave(filename = paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/","StartPopSz",unique(harvestsims_endpop[[i]][[j]]$StartPopSz),
                            "ClusterCol", unique(harvestsims_endpop[[i]][[j]]$CollClu),"_endpopsz.jpg",sep=""),
           ggplot(harvestsims_endpop[[i]][[j]], aes(DistGB, DiffEndPopsz, colour = as.factor(lifespan)))+
             # geom_point(size=0.25, alpha=0.25)+
             stat_smooth(method = "lm", formula = y ~ x + I(x^2),se = FALSE)+ #method = "loess"
             theme_bw()+
             scale_color_discrete(name="Lifespan")+             
             labs(title = str_wrap(paste("Difference in years to extinction at harvest level: ",unique(harvestsims_endpop[[i]][[j]]$Harvest), 
                                         ", starting population size ",unique(harvestsims_endpop[[i]][[j]]$StartPopSz), 
                                         ", and clusters of ", unique(harvestsims_endpop[[i]][[j]]$CollClu), 
                                         " consecutive years of collection.", sep=""), width = 70),
                  x = "Periodicity",
                  y = "Final population size as a percent of no harvest"),
           width=300, height=300,units='mm', dpi=300)
  }
}
  

```

# make this generalizable 
```{r}
pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/"
startpop <- c(10,100,500, 1500)
clucol <- c(1,3,5)
cores <- detectCores()-1

# test
# s <- startpop[1]
# clust <- clucol[1]
# i <- 0.6
# x <- resultpath[5]
# harv <- harvestlevels[17]
# GB <- unique(noANDharvest$GB_mat)[2]
# rm(s);rm(cl);rm(x);rm(harv);rm(GB)

# takes a lot of energy and memory because it has to save the output of each lapply and bind it but I want all that

harvestsims <- lapply(startpop, function(s){ 
  clusters <- lapply(clucol, function(clust){ 
      ints <- lapply(seq(0.1,1,by=0.1), function(i){
        resultpath <- list.files(path = pathstart, 
                                 pattern = paste("popsz",s,"AvgIntensity",i,"clustersz",clust,"GB2","reps100",sep=""), 
                                 full.names=TRUE)
        files <- do.call(rbind,lapply(resultpath, function(x){
          load(x) # loads a noANDharvest simulation for a species/clustersize/popsize/variableGBs
          harvestlevels <- levels(factor(noANDharvest$Harvest))
          diff.time2ext <- do.call(rbind,lapply(harvestlevels[harvestlevels!="0:0:0:0"] ,function(harv){ # how many columns of frequency and intensity rates
            diff.endpop <- do.call(rbind,lapply(1:10, function(reps){
              if(any(!is.na(noANDharvest$EndPopSz[noANDharvest$Harvest=="0:0:0:0"])) &
                 any(!is.na(noANDharvest$EndPopSz[noANDharvest$Harvest==harv]))){
                noharvest <- noANDharvest[noANDharvest$Harvest=="0:0:0:0" & !is.na(noANDharvest$EndPopSz),]  
                harvest <- noANDharvest[noANDharvest$Harvest==harv & !is.na(noANDharvest$EndPopSz),] 
                har_idx <- sample(1:nrow(harvest), size = 1)
                out <- data.frame(DiffEndPopSz = log(harvest$EndPopSz[har_idx])/log(sample(noharvest$EndPopSz, size = 1)),
                                  GB_matrix = harvest$GB_mat[har_idx], IntensityRatio = harvest$IntRatio[har_idx],
                                  Harvest = harv, lifespan = unique(noANDharvest$lifespan), SPP = unique(noANDharvest$SPP),
                                  StartPopSz = s, CollClu = clust, AverageIntensity = i)
                out
                } # end if
                }))
              diff.endpop
            })) # end do.call for harvest levels
          diff.time2ext
        }))
        files
      })
      ints
      })
  clusters
  })

table(harvestsims[[1]][[1]][[1]]$StartPopSz,harvestsims[[1]][[1]][[1]]$SPP)
# 
# for(i in 1:4){ # for the starting population sizes
#   for(j in 1:3){ # each sub-list has three, 1, 3, and 5 consecutive years of collections
#     for(k in 10){ # for each average intensity seq(0.1, 1, by=0.1)}
#     ggsave(filename = paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/","StartPopSz",unique(harvestsims[[i]][[j]][[k]]$StartPopSz),
#                             "ClusterCol", unique(harvestsims[[i]][[j]][[k]]$CollClu),"AvgInt",
#                             unique(harvestsims[[i]][[j]][[k]]$AverageIntensity),"_time2ext.jpg",sep=""),
i<-2;j<-1;k<-4
           ggplot(harvestsims[[i]][[j]][[k]], aes(IntensityRatio, DiffEndPopSz, colour = as.factor(lifespan)))+
             # geom_point(size=0.25, alpha=0.25)+
             stat_smooth(method = "lm", formula = y ~ x + I(x^2),se = FALSE)+ #method = "loess"
             theme_bw()+
             scale_color_discrete(name="Lifespan")+             
             labs(title = str_wrap(paste("Difference in final population size at frequency = 0.1, 
                                         average intensity = ",
                                         unique(harvestsims[[i]][[j]][[k]]$AverageIntensity),
                                         ", starting population size ",unique(harvestsims[[i]][[j]][[k]]$StartPopSz), 
                                         ", and clusters of ", unique(harvestsims[[i]][[j]][[k]]$CollClu), 
                                         " consecutive years of collection.", sep=""), width = 70),
                  x = "Good to Bad intensity ratio",
                  y = "Time to exctinction as a percent of no harvest") #,
#            width=300, height=300,units='mm', dpi=300)
#   }
# }
# }
    
```




#Simulate various levels of harvest changing one factor at a time. Copy of changing the good-bad but it's a little different  
```{r}
cores <- detectCores()-1
GBmatrix <- list(matrix(c(0.15,0.85,0.15,0.85), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad"))), # 
                 matrix(c(0.45,0.55,0.45,0.55), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad"))), # 
                 matrix(c(0.55,0.45,0.55,0.45), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad"))), # 
                 matrix(c(0.85,0.15,0.85,0.15), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad")))) # 

FreqRates <- cbind(rbind(.1,.1))
totyr <- 50*(floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp])) # make it 100*lifespan
startpop <- c(10,100,500,1500)
clucol <- c(1,3,5)
rep_gb <- 100 # for testing, make 100

lapply(unique(tm$SPP)[-2], function(sp){ # [-2]CIPI has one population with different number of stages
  # for(GB in 1:4){
    startszout <- lapply(3:4, function(popsz){
      clusterout <- lapply(2:3, function(csz){ # clustered collection number of years
        GBout <- lapply(c(1,3:4), function(gb){
          intensity <- lapply(seq(0.1,1,by = 0.1), function(avgInt){
            cl <- makeCluster(cores)
            registerDoParallel(cl)
            noANDharvest <- foreach(freqreps = 1:rep_gb,
                                    .packages = c("popbio"),
                                    .export = c(ls(globalenv()), "popsz","csz","gb"), 
                                    # c("AnnualTransition","sp","SeedHarvestSim","Mx_all","TMx_all","Mx_all","Nx_names"),
                                    .combine = "rbind") %dopar% 
              { # Replicates of different intensities
                intB <- round(runif(1, min = 0, max = min((2*avgInt),1)),2); intG <- 2*avgInt - intB; if(intG>1) intG <- 1
                noharvest <- do.call(rbind, lapply(1:2, function(x){ # replicates
                  out_rep <- SeedHarvestSim(Mx_list = Mx_all[grep(sp, unlist(Nx_names))], 
                                            TMx_list = TMx_all[grep(sp, unlist(Nx_names))],
                                            Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
                                            StartPopSize = startpop[popsz],
                                            GoodBadTm = GBmatrix[[gb]],
                                            Freq = c(0,0),
                                            Int = c(0,0),
                                            TotYrs = totyr,
                                            ClusteredColl = clucol[csz])
                  out_n <- data.frame(SPP = sp, EndPopSz = out_rep[[1]]$PopulationSize[nrow(out_rep[[1]])],  # End population size
                      Replicate = x,GoodFreq = 0,BadFreq = 0,GoodInt = 0, BadInt = 0, 
                      Harvest = paste(0, 0, 0, 0, sep=":"),
                      IntRatio = intG/intB, # the ratio of good year intensity to bad year intensity when average is set
                      GB_mat = paste(as.vector(GBmatrix[gb]), collapse = ":"),
                      Lifespan = floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp]), 
                      # Time to extinction: the first year the population falls below 1; when never met which.max returns 1
                      Yr2Ext = which(out_rep[[1]]$PopulationSize<1)[1], 
                      lifespan = floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp]),
                      CollectionYrs <- clucol[csz],
                      StartPopSize = startpop[popsz])
                  out_n
                  })) # end no harvest
                harvestfreq.int <- do.call(rbind,apply(FreqRates, 2, function(f){
                nowharvest <- do.call(rbind,lapply(1:1, function(x){ # without parallel; replicates of frequency
                  Intout <- do.call(rbind,lapply(1:100, function(irep){ # make 1:1000 after it works, selecting new intensities
                    # i <- c(runif(1, min = 0, max = 1),runif(1, min = 0, max = 1)) # 1000 replicates of random selection of a good and bad intensity
                    # i1 <- runif(1, min = 0, max = 1)
                    # i <- c(i1,i1)
                    out_rep <- SeedHarvestSim(Mx_list = Mx_all[grep(sp, unlist(Nx_names))],
                                              TMx_list = TMx_all[grep(sp, unlist(Nx_names))],
                                              Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
                                              StartPopSize = startpop[popsz],
                                              GoodBadTm = GBmatrix[[gb]],
                                              Freq = c(f[1],f[2]),
                                              Int = c(intG,intB),
                                              TotYrs = totyr,
                                              ClusteredColl = clucol[csz])
    
                  out_n <- data.frame(SPP = sp, EndPopSz = out_rep[[1]]$PopulationSize[nrow(out_rep[[1]])],  # End population size
                      Replicate = x,GoodFreq = f[1],BadFreq = f[2],GoodInt = intG, BadInt = intB, 
                      Harvest = paste(f[1], f[2], intG, intB, sep=":"),
                      IntRatio = intG/intB, # the ratio of good year intensity to bad year intensity when average is set
                      GB_mat = paste(as.vector(GBmatrix[gb]), collapse = ":"),
                      Lifespan = floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp]), 
                      # Time to extinction: the first year the population falls below 1; when never met which.max returns 1
                      Yr2Ext = which(out_rep[[1]]$PopulationSize<1)[1], 
                      lifespan = floor(lifespan.sp$lifespan[lifespan.sp$SPP==sp]),
                      CollectionYrs <- clucol[csz],
                      StartPopSize = startpop[popsz])
                  out_n
                    }))
                  Intout
                  }))
                nowharvest
                })) # end harvestfreq.int apply and rbind
                ynharvest <- rbind(noharvest, harvestfreq.int)
                ynharvest
                } # foreach loop for replicates of average intensity
            on.exit(stopCluster(cl))
            save(noANDharvest, file = paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/IntensitynoANDharvest",sp,"popsz",startpop[popsz],
                                            "AvgIntensity",avgInt,"clustersz",clucol[csz],"GB",gb,"reps",rep_gb,".Rdata",sep=""))
            }) # Lapply for average intensity levels
          }) # good-bad transition matrices
        }) # lapply for how many years of collections
      }) # loop for population starting sizes
    }) # loop for all species


```









######################################
Visualize difference between no harvest and each rate:freq per climate periodicity projection


Constrain      
End population size
```{r}
for(sp in c("CYFA",sp,"ERCU","HYCU","HARA","PHEM")){
  for(GB in 1:4){
    for(popsz in 1:4){
      GoodBad <- c("radnom","mostlybad","mildclustered","mostlygood")
      GBmatrix <- list(matrix(c(0.5,0.5,0.5,0.5), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad"))), # random
                       matrix(c(0.25,0.75,0.25,0.75), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad"))), # extreme drought
                       matrix(c(0.55,0.45,0.45,0.55), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad"))), # mild clustered
                       matrix(c(0.75,0.25,0.75,0.25), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad")))) # mostly good
      # Intensityrates <- cbind(rbind(seq(0.1,1,by=0.1),seq(0.1,1,by=0.1)),combn(seq(0,1,by=0.1),2))
      Intensityrates <- cbind(rbind(seq(0.1,1,by=0.1),seq(0.1,1,by=0.1)))
      # FreqRates <- cbind(rbind(seq(0.1,1,by=0.1),seq(0.1,1,by=0.1)))
      FreqRates <- cbind(rbind(c(.1,.5,1),c(.1,.5,1)))
      # sp <- unique(tm$SPP)[5]
      totyr <- 100
      startpop <- c(100,500,1000,10000)
      
      # Keeping total years of the simulation and the good to bad year transition matrix constanst, compare time to exticntion for no harvest
      # compare_sp <- do.call(rbind, apply(Intensityrates, 2, function(i){
          noharvest <- do.call(rbind, lapply(1:100, function(x){
            out_rep <- SeedHarvestSim(Mx_list = Mx_all[grep(sp, unlist(Nx_names))], 
                                      TMx_list = TMx_all[grep(sp, unlist(Nx_names))],
                                      Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
                                      StartPopSize = startpop[popsz],
                                      GoodBadTm = GBmatrix[[GB]],
                                      Freq = c(0,0),
                                      Int = c(0,0),
                                      TotYrs = totyr,
                                      ClusteredColl = 3)
            out_rep[[1]]$Replicate <- x
            out_rep[[1]]$Year <- 1:totyr
            out_rep[[1]]$GoodFreq <- 0
            out_rep[[1]]$BadFreq <- 0
            out_rep[[1]]$GoodInt <- 0
            out_rep[[1]]$BadInt <- 0
            out_rep[[1]]
            }))
    
      # Pop size at end of simulation      
      endpopsize.noharvest <- do.call(rbind,lapply(split(noharvest, noharvest$Replicate), function(x){
        x[x$Year == totyr,]
      }))    
      
      # n.cores <- detectCores()-1
      harvestfreq.int <- do.call(rbind, apply(FreqRates, 2, function(f){
            Intout <- do.call(rbind, apply(Intensityrates, 2, function(i){
                # clust <- makeCluster(n.cores)
              # cl <- makeCluster(mc <- getOption("cl.cores", 3))
              #   clusterExport(cl, varlist=c("x","f","i","SeedHarvestSim","stable.stage","Mx_all","Nx_names",
              #                                  "GBmatrix","TMx_all","sp","AnnualTransition"), envir = environment()) # can also import packages , envir = environment()
              # nowharvest <- do.call(rbind, parLapply(cl, 1:100, function(x){ # with parallel
              nowharvest <- do.call(rbind, lapply(1:100, function(x){ # without parallel
                out_rep <- SeedHarvestSim(Mx_list = Mx_all[grep(sp, unlist(Nx_names))], 
                                          TMx_list = TMx_all[grep(sp, unlist(Nx_names))],
                                          Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
                                          StartPopSize = startpop[popsz],
                                          GoodBadTm = GBmatrix[[GB]],
                                          Freq = c(f[1],f[2]),
                                          Int = c(i[1],i[2]),
                                          TotYrs = totyr,
                                          ClusteredColl = 3)
                out_rep[[1]]$Replicate <- x
                out_rep[[1]]$Year <- 1:totyr
                out_rep[[1]]$GoodFreq <- f[1]
                out_rep[[1]]$BadFreq <- f[2]
                out_rep[[1]]$GoodInt <- i[1]
                out_rep[[1]]$BadInt <- i[2]
                out_rep[[1]]
                }))
              nowharvest
              }))
            # stopCluster(clust)
            Intout
            }))
      
      time2extinct <- as.data.frame(do.call(rbind,lapply(split(harvestfreq.int, harvestfreq.int$GoodFreq), function(y){
        out.freq <- do.call(rbind,lapply(split(y, y$GoodInt), function(x){
          out.good <- do.call(rbind,lapply(split(x, x$BadInt), function(x1){
       out.bad <- do.call(rbind,lapply(split(x1, x1$Replicate), function(x2){
              Time2Exc <- which(x2$PopulationSize<1)[1] # To get the first year the population falls below 1
              GoodInt <- unique(x2$GoodInt)
              BadInt <- unique(x2$BadInt)
              GoodFreq <- unique(x2$GoodFreq)
              BadFreq <- unique(x2$BadFreq)
              Replicate <- unique(x2$Replicate)
              out <- c(Time2Exc, GoodInt, BadInt, GoodFreq, BadFreq, Replicate)
              out
            }))
            out.bad
          }))
          out.good
      }))
        out.freq
      })))
      
      names(time2extinct) <- c("Years", "GoodInt", "BadInt", "GoodFreq", "BadFreq", "Replicate")
      
      time2ext.df.noharvest <- data.frame(Years = time2extinct.noharvest, GoodInt = rep(0,100), BadInt = rep(0,100), 
                                                GoodFreq = rep(0,100), BadFreq = rep(0,100), Replicate = as.numeric(names(time2extinct.noharvest)))
      
      time2ext.df <-rbind(time2ext.df.noharvest, time2extinct)
      time2ext.df$Harvest <- paste(time2ext.df$GoodFreq, time2ext.df$BadFreq, time2ext.df$GoodInt, time2ext.df$BadInt, sep=":")
      HarLev <- c("0:0:0:0",levels(factor(time2ext.df$Harvest))[c(1:20,22:31)])
      time2ext.df$Harvest <- factor(time2ext.df$Harvest, levels = HarLev)

      ggsave(filename = paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/",GoodBad[GB],"_StartPopSz_",startpop[popsz],"_",sp,"_time2ext.jpg",sep=""),
             ggplot(time2ext.df, aes(Harvest, Years, colour = Harvest))+
               geom_boxplot()+
               theme(legend.position="none",
                     axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
                     panel.background = element_rect(fill = "white", colour = "grey75"))+
               geom_jitter(),
        width=300, height=300,units='mm', dpi=300)
    }
  }
}



```


Cycle through combinations of 0 to 100% of the frequency and intensities from no harvest, through equal rates regardless of good or bad, and all combinations.     
If I set this up as a continuous relationship (suggested by Anna) there would be fewer needed replicates and parameters, could vary the slope of the relationship instead of descrete percentages by good vs. bad.        
Either through a beta distribution; rbeta: two non-negative shape parameters where mean = a/(a+b) and variance is ab/((a+b)^2 *(a+b+1)) or a linear regression defining the slope     
```{r}

# Discrete rates
GBmatrix <- matrix(c(0.45,0.55,0.35,0.65), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad")))
Intensityrates <- cbind(rbind(seq(0.1,1,by=0.1),seq(0.1,1,by=0.1)),combn(seq(0,1,by=0.1),2))
FreqRates <- cbind(rbind(seq(0,1,by=0.1),seq(0,1,by=0.1)),combn(c(0,0.1,0.2,0.5,0.75,1),2))
sp <- unique(tm$SPP)[5]


# Keeping total years of the simulation and the good to bad year transition matrix constanst, compare time to exticntion for no harvest
compare_sp <- do.call(rbind, apply(Intensityrates, 2, function(i){
  outf <- do.call(rbind, apply(FreqRates, 2, function(f){
    compare_out <- do.call(rbind, lapply(1:100, function(x){
      out_rep <- SeedHarvestSim(Mx_list = Mx_all[grep(sp, unlist(Nx_names))], 
                                 TMx_list = TMx_all[grep(sp, unlist(Nx_names))],
                              Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
                              StartPopSize = 500,
                              GoodBadTm = GBmatrix,
                              Freq = f,
                              Int = i,
                              TotYrs = 100,
                              ClusteredColl = 3)
      out_rep[[1]]$Replicate <- x
      out_rep[[1]]$Year <- 1:100
      out_rep[[1]]$GoodFreq <- f[1]
      out_rep[[1]]$BadFreq <- f[2]
      out_rep[[1]]$GoodInt <- i[1]
      out_rep[[1]]$BadInt <- i[2]
      out_rep[[1]]
      }))
    compare_out
    }))
  outf
  }))


splitXgoodFreq <- split(compare_sp, as.factor(compare_sp$GoodFreq))

ggplot(splitXgoodFreq[[1]][splitXgoodFreq[[1]]$BadFreq == 0.1,], aes(Year, PopulationSize, colour = as.factor(Replicate)))+
  geom_line()+
  theme(legend.position="none")+
  facet_wrap(~as.factor(GoodInt))
 
ggplot(compare_sp[compare_sp$GoodFreq == 1 & compare_sp$BadFreq == 1 & compare_sp$GoodInt == 1 & compare_sp$BadInt == 1 &
                    compare_sp$Replicate < 11,], aes(Year, PopulationSize, colour = as.factor(Replicate)))+
  geom_line()+
  theme(legend.position="none")+
  facet_wrap(~as.factor(Replicate))

time2extinct <- sapply(split(compare_DIFR, compare_DIFR$Replicate), function(x){
  which.max(x$PopulationSize<1) # To get the first year the population falls below 1
})

hist(time2extinct)

```













Example data for Sclerocactus glaucus where size measurements are the width at widest point for these ball cacti
't0' and 't1' are the widths (cm) and survival is for the tagged cactus from year t to t+1. 'reproyesno' is for 't0'. 'flowers0' is a Poisson distribution based on a linear model of number of flowers by size on the one year we took that data. 'minis0' and 'minis1' are the number of seedlings (cacti with < 0.5 cm in width) in year t and t+1

# Integral projeciton models
Merow et al 2014 Advancing population ecology   
```{r}

# make an S4 class object? 
params <- data.frame(
  surv.int=NA, # Intercept from logistic regression of survival
  surv.slope=NA, # Slope from logistic regression of survival
  growth.int=NA, # Intercept from linear regression of growth
  growth.slope=NA, # Slope from linear regression of growth
  growth.sd=NA, # Residual sd from the linear regression of growth
  seed.int=NA, # Intercept from Poisson regression of seed number
  seed.slope=NA, # Slope from Poisson regression of seed number
  recruit.size.mean=NA, # Mean recruit size
  recruit.size.sd=NA, # Standard deviation of recruit size
  establishment.prob=NA # Probability of establishment
)
```


# build vital rate regressions and store coefficients  
# Assume most populaitons will have different responses by site but check. Limitation might be due to sample (populaiton) size leading to lumping or splitting data by population. 
```{r}
# example data frame
size_scgl

# Test if there are differences in vital rates among sites and years

ggplot(size_scgl, aes(t0, survival, colour = Site))+
  geom_point()+
  theme_bw()+
  geom_jitter(height = 0.1, width = 0)+
  facet_wrap(~Site)+
  stat_smooth(method="glm", family=binomial, formula=y~x,
              alpha=0.2, size=1, colour="black")

ggplot(size_scgl, aes(t0, survival, colour = Site))+
  geom_point()+
  theme_bw()+
  geom_jitter(height = 0.1, width = 0)+
  facet_wrap(~year0)

# survival
surv.reg1 <- glm(survival ~ t0 + Site + as.factor(year0), data = size_scgl, family = binomial()) # survival by size (slope) comparing different intercepts by site and year
surv.reg2 <- glm(survival ~ t0, data = size_scgl, family = binomial()) # survival by size (slope)
# Could compare different slope and intercept by site and year but doesn't that overfit??

reg.list <- list(surv.reg1, surv.reg2)
reg.names <- as.character(unlist(lapply(reg.list, formula)))
(reg.results <- aictab(reg.list, modnames = reg.names))

summary(surv.reg1)

params$surv.int <- c(rep(coefficients(surv.reg1)[1], length(coefficients(surv.reg1))-2)+coefficients(surv.reg1)[-c(1:2)] )# all the offsets for year and site
```



# Code adapted from Dan Doak for an IPM

```{r}

# Unknown, test correlation of t-1, t-2 ... reproductive output on seedlings to see if there's an indication of a persistent seed bank
seedlings_per_seed_sg <- 10/500 # 0.000001 # the rate that a seed germinates I'm making a wild estimate

# Changed our methods from measuring all individuals to only measuring individuals >= 0.5 cm width in 2012. 
surv_minis <- 0.69 # this is an average of two estimates, should test both 0.59 and 0.78

# set the minimum size and maximum size
minsize_scgl <- 0.01
maxsize_scgl <- 12.61 # was Fram, excluded 14.51

```


Size density estimation for median size estimation - for each kernel, the state of an individual at one time that dictates the state and state of any offspring at the next time step (Merow et al. 2014 "Advancing population ecology with integral projeciton models: a practical guide")
```{r}

pdfsz_scgl <- density(size_scgl$t0, n=1024, cut=0, na.rm = TRUE)
pdfsz2_scgl <- cbind(pdfsz_scgl$x,pdfsz_scgl$y)
plot(pdfsz2_scgl, type="l")

```

### Matrix Model 
  Estimate vital rates, populate matrix, for models with different numbers of classes/ bins    

```{r ScGl matrix}
# testing
# seedlings_per_seed <- seedlings_per_seed_sg # not sure if this should be the chance a seed turns into a seedling or something else or how to pick the value
# testbins <- c(4,5,6,7,8,10,15,19) # I don't have enough individuals to get estimates if I break this into too many bins
# df <- size_scgl
# minsize <- minsize_scgl
# maxsize <- maxsize_scgl
# bin.num <- testbins
# allsdszs <- allsdszs_scgl # the distribution of sizes you classify as a seedling
# surv_seedlings <- surv_minis # calculated from using the size class defined as seedlings in time t and the annual surival to t+1; seedling size vs. the smallest bin size which might include more than survival of seedlings
# bin.num <-  c(4,5,6,7,8)
# i <- 3
# seeds_per_flower <- 150
# rm(bin.num); rm(i); rm(df);rm(seedlings_per_seed);rm(minsize); rm(maxsize); rm(allsdszs); rm(surv_seedlings); rm(seeds_per_flower)

IPM_basic <- function(df, bin.num, seedlings_per_seed, surv_seedlings, seeds_per_flower, seedling_size){
    # Empty list items
    lambdas_matrix <- rep(NA, length(bin.num))
    dampratio_matrix = rep(NA, length(bin.num))
    lifespan_matrix=rep(NA, length(bin.num))
    mincounts=NULL
    minsize <- min(c(df$t0, df$t1), na.rm=TRUE) -0.01
    maxsize <- max(c(df$t0, df$t1), na.rm=TRUE) +0.01
    allsdszs <- df$t0[df$t0 < seedling_size]
    # test each number of bins, break by size 
    for(i in 1:length(bin.num)){
      ss=as.numeric(df$t0)
      vec.bin = c(minsize, minsize+1:bin.num[i]*(maxsize-minsize)*(1/bin.num[i])) # the upper and lower size limits to make the designated number of bins
      nums=hist(ss,breaks=vec.bin, plot=FALSE)$counts  # the number of individuals that fall in each group
      mincounts=c(mincounts,min(nums))
      
      if (min(nums)>2) {  
        ## Initialize storage
        n.bin <- length(vec.bin)-1            # this is a workaround
        n <- rep(NA, n.bin)                   # count of indvs per bin
        medians <- rep(NA, n.bin)             # median size per bin for F
        surv <- rep(NA, n.bin)                # survivorship for each class
        grow <- matrix(NA, n.bin, n.bin)      # store growth probabilites for each class
        reproduction <- rep(NA, n.bin)        # store reproduction probabilites for each class
        
        totnums = 0 # this is just monitoring for errors, start at zero before next loop per size subset
        # bin, survival, growth
         for(j in 1:(length(vec.bin)-1)){
          # set limits for size subset according to bin breaks
          bounds <- c(vec.bin[j], vec.bin[j+1])
          # subset data according to bounds
          subset <- df[df$t0 > bounds[1] & df$t0 <= bounds[2],]
          # store number of inviduals in this bin for future reference
          n[j] <- length(subset$t0)
          medians[j] <- median(subset$t0)
          # calculate survivorship for this class
          surv[j] <- sum(subset$survival) / length(subset$t0) # of those alive in year 1, how many survived by bin/size class
          # store histo as object, to access counts per bin
          histo <- hist(subset$t1, breaks = vec.bin, plot = FALSE)
          # $counts returns the number of individuals of a certain size class
          grow[,j] <- histo$counts/length(subset$t0[subset$survival==1]) 
          reproduction[j] <- mean(subset$flowers0*seeds_per_flower, na.rm = TRUE) # seedlings produced per plant in start yr
          
          totnums = totnums + sum(histo$counts)
        }
        
        # make a vector of the prob of seedling sizes: 
        sdlggrow <- hist(allsdszs, breaks = vec.bin, plot = FALSE)$counts/length(allsdszs)
        reproduction[is.nan(reproduction)] <- 0
        
        M1 <- matrix(NA, n.bin, n.bin)   # initiate projection matrix
        M <- matrix(0, (n.bin+1), (n.bin+1))
        # populate projection matrix
      
        for(j in 1:length(surv)){
          M1[,j] <- surv[j] * grow[,j]
          M1[,j] <- (surv[j] * grow[,j])
        }
          
          # add lines for the creation of bulblings and thier transition to first size class
          M[2:(n.bin+1), 2:(n.bin+1)] = M1
          M[2:(n.bin+1),1] = surv_seedlings*sdlggrow 
          M[1,2:(n.bin+1)] = reproduction*seedlings_per_seed  
        
        
        lambdas_matrix[i] <- lambda(M) # calls popbio f'n 'lambda'
        dampratio_matrix[i]=damping.ratio(M)
        lifespan_matrix[i] =lifespan(M)
        
        print(c(i,totnums)) 
      } else {
        lambdas_matrix[i]=NA
        dampratio_matrix[i] = NA
        lifespan_matrix[i] = NA
      }
    }
    list(lambdas_matrix, dampratio_matrix, lifespan_matrix)
}
```






Not by site but across all data, use site, year, and fecundity as a covariate, predict for high and low values 
```{r}
# ScGl
# seedlings_per_seed # not sure if this should be the chance a seed turns into a seedling or something else or how to pick the value
testbins <- c(4,5,6,10,30,50,100) # I don't have enough individuals to get estimates if I break this into too many bins
# df <- size_scgl
# minsize <- minsize_scgl
# maxsize <- maxsize_scgl
# bin.num <- testbins
# allsdszs <- allsdszs_scgl # the distribution of sizes you classify as a seedling
# surv_seedlings <- surv_minis # calculated from using the size class defined as seedlings in time t and the annual surival to t+1; seedling size vs. the smallest bin size which might include more than survival of seedlings

scgl_IPM_all <- IPM_basic(df = size_scgl, seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150, seedling_size = 0.5)

scgl_IPM_all


scgl_IPM_NS <- lapply(unique(size_scgl$Region), function(x){
  IPM_basic(df = size_scgl[size_scgl$Region == x,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150,  seedling_size = 0.5)
  })

sites <- c("Atwell Gulch","Picnic Site","Powerline","Pyramid Rock","T-Junction")
 #unique(size_scgl$Site)
scgl_IPM_sites <- lapply(c("Atwell Gulch","Escalante Canyon","Picnic Site","Pyramid Rock"), function(x){
  print(x)
  IPM_basic(df = size_scgl[size_scgl$Site == x,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins,  seedling_size = 0.5, surv_seedlings = surv_minis, seeds_per_flower = 150)
})

# Errors -Inf
scgl_IPM_Site_year <- lapply(c("Atwell Gulch","Escalante Canyon","Picnic Site","Pyramid Rock"), function(x){
  lapply(unique(size_scgl$year0[size_scgl$Site == x]), function(y){
    print(x);print(y)
  IPM_basic(df = size_scgl[size_scgl$Region == x & size_scgl$year0 == y,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150,  seedling_size = 0.5)
  })
})


scgl_IPM_NS_year <- lapply(unique(size_scgl$Region), function(x){
  lapply(unique(size_scgl$year0[size_scgl$Region == x]), function(y){
    print(x);print(y)
  IPM_basic(df = size_scgl[size_scgl$Region == x & size_scgl$year0 == y,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150,  seedling_size = 0.5)
  })
})


```


```{r}
(lambdas_matrix)
(dampratio_matrix)
(lifespan_matrix)

```

Make a predictive model (as a function only of size in this case) and site, year, and fecundity for each demographic rate: survival, mean growth, variance in growth, prob of reproducing, and how much reproduction if reproducing. The code fits a few alternatives and chooses the best one for each rate, which will be used below. But can't have fecundity in the reproductive ones... ???
```{r}
## Vital rates
# survival
######## ScGl survival #########################
# do it my way 

glm1 <- glm(survival ~ t0, family = "binomial", data = size_scgl)
# glm2 <- glm(survival ~ t0 + t0sq, family = "binomial", data = size_scgl) # don't have a squared term yet, need it?
glm3 <- glm(survival ~ t0 + Site + t0*Site, family = "binomial", data = size_scgl1) # The slope and the intecept could differ
glm4 <- glm(survival ~ t0 + as.factor(year0) + t0*year0, family = "binomial", data = size_scgl1)
glm5 <- glm(survival ~ t0 + as.factor(year0) + t0*as.factor(year0) + Site + t0*Site + as.factor(year0)*Site, family = "binomial", data = size_scgl1)

lm.list <- list(glm1, glm3, glm4, glm5)
lm.names <- as.character(unlist(lapply(lm.list, formula)))
(lm.results <- aictab(lm.list, modnames = lm.names))
# evidence ratio
for(i in 2:length(lm.list)){
  print(exp(0.5*lm.results$Delta_AICc[i]))
}

summary(glm5)

ggplot(size_scgl, aes(t0, survival, colour = Site))+
  geom_point()+
  stat_smooth(method="glm", family=binomial, formula = y~x, aes(fill=Site))+
  facet_grid(cols=vars(year0),
             rows = vars(Site))+
  xlab("Size at time t")+
  ylab("Survival to time t+1")+
  theme_bw()

```


```{r}
# Growth

# growth: non-linear with linear function of size , quadratic function of size, power function (A+B*(size^C))
# nlm1 <- nls(t1 ~ a + b*t0, data = size_scgl, start = list(a=1, b=1))
# nlm2 <- nls(t1 ~ a + b*t0 + c*Site, data=size_scgl, start = (list(a=1, b=1, c=1)))
# nlm3 <- nls(t1 ~ a + b*t0 + c*year0, data=size_scgl, start=list(a=1, b=1, c=1))

glm1 <- glm(t1 ~ t0, family = poisson, data = size_scgl)
nlm.list <- list(nlm1, nlm2, nlm3)
nlm.names <- as.character(unlist(lapply(nlm.list, formula)))
(nlm.results <- aictab(nlm.list, modnames = nlm.names))
for(i in 2:length(nlm.list)){
  print(exp(0.5*nlm.results$Delta_AICc[i]))
}

# getting residuals of growth
size$growth_residuals <- NA
size$growth_residuals[which(!is.na(size$t1) & !is.na(size$t0))] <- summary(bestgrowth)$residuals^2

summary(glm1)

```



# code snipit graveyard

# Sensitivities and elasticites    
<http://ecovirtual.ib.usp.br/doku.php?id=en:ecovirt:roteiro:pop_str:pstr_ser> 
```{r}
eigen.all <- lapply(Mx_all, function(mx){
  eigen(mx)
})

# transposed to get w: stable stage vector
# Or to get reproductive values because the left eigenvectors are equal to the right eigenvectors of the transpose matrix. i.e. you transpose and use eigen() to find the left eigenvector - the eigenvalues will be the same
eigen.tall <- lapply(Mx_all, function(mx){
  eigen(t(mx))
})

lamb.all <- lapply(eigen.all, function(x){
  max(Re(x$values)) # check if lambda 1 agrees with the expected
})

v.all <- lapply(eigen.all, function(x){
  Re(x$vectors[,which.max(Re(x$values))]) # proportional reproductive value
})

# ???standardized reproductive value
vr.all <- lapply(v.all, function(x){
  x/x[1]
})

w.all <- lapply(eigen.tall, function(x){
  Re(x$vectors[,which.max(Re(x$values))]) # stable stage vector
})

wsum.all <- lapply(w.all, function(x){
  x/sum(x)
})

# ???
# <http://biom300.weebly.com/eigenvalues-and-eigenvectors-in-r.html> 
# divide by the first non-zero entry to calcuate relative reproductive values (should be the same as vr.all above) but is not
repro.value <- mapply(function(l,r) l$vectors[,1]/r$vectors[1,1] ,eigen.tall, eigen.all)
stable.stages <- lapply(Mx_all, function(x){
  eigen(x)$vectors[,1]/(sum(eigen(x)$vectors[,1]))
})

# mean reproductive value 
mean.repro <- mapply(function(r,s) r%*%s, repro.value, stable.stages)
unlist(mean.repro)

### Sensitivity
vms.all <- mapply(function(v,w) v %*% t(w), vr.all, w.all)
S.all <- mapply(function(vms, vr, w) vms/as.numeric(vr %*% w), vms.all, vr.all, w.all)


### Elasticity
elast <- mapply(function(mx, l, Ss) (mx/l)*Ss, Mx_all, lamb.all, S.all)

### Compare to popbio()
ea.all <- lapply(Mx_all, function(x) eigen.analysis(x))


eigen.all[[1]];eigen.tall[[1]];lamb.all[[1]];v.all[[1]];S.all[[1]];vmx.all[[1]];ea.all[[1]]
vr.all[[1]];elast[[1]]

cory<-matrix(c(0.434, 0.333,0,0,0.61, 0.304,0.56, 0, 0.956), ncol=3, nrow=3)
cory
n0=matrix(c(10,5,2), ncol=1)
## tempo 1
	n1 <-  cory %*% n0 
	n1[3] <- n1[3]-0.2 * n1[3] # simulates a 20% post-reproductive extraction of adulats

eigen.analysis(cory)
```




```{r}

pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Simulation_output/"

ncores <- detectCores()-1
cl <- makeCluster(ncores)
doParallel::registerDoParallel(cl, ncores)

# i<- 0.1
# xfile <- resultpath[[1]]

compars <- lapply(seq(0.1,1,by=0.1),function(i){  #
  resultpath <- list.files(path = pathstart, 
                           pattern = paste("Cluster1AvgInt",i,"Freq","0.1",sep=""),
                           full.names = TRUE)
  foreach(xfile  = resultpath,
          .combine = "rbind") %dopar% {
            load(xfile)
            out
            }
  })
stopCluster(cl)

head(compars)


```

      if(ddceiling == TRUE){ # instead use some stochastic process (see Anna's paper) to multiple and still have a matrix reflecting seed harvest,
        # option 1: in absence of transition-specific density dependence (but maybe there is more likely more seed production at greater densities - remove pollen limitation, but lower recruitment survival due to high densities) then a straight across classes lowering of number of individuals in each stage by the difference between total population size and maximum population size as the logistic term - replace growth rate by the dominant eigenvalue of the transition matrix.  
        # A hard cap or ceiling negates the effect of seed harvest
      if(sum(onetransition[[1]]) < ceil){
        vec <- onetransition[[1]]
        }
      } else {
        vec <- onetransition[[1]]
        } # done with density dependent ceiling
      } # end density dependence
