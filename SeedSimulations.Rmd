---
title: "SeedHarvestSimulations"
author: "Michelle DePrenger-Levin"
date: "9/8/2020"
output: html_document
---

ctrl+Alt+Shift+M == rename in scope
Ran too many print(df) and it busted RStudio
---
title: "Seed Harvest IPM and MPM"
author: "Michelle DePrenger-Levin"
date: "7/26/2020"
output: html_document
---

```{r}

rm(list=ls())
library(dplyr)
library(popbio)
library(MuMIn)
library(binr)
library(matrixStats)
require(AICcmodavg)
library(prism)
library(raster)
library(lme4)
library(ggplot2)
library(patchwork)
# install.packages("roxygen2")

library(stringr)

# Plotting response curves
library(scales)
library(splines)
library(MASS)
library(nlme)

library(parallel); library(doParallel); library(foreach)

# plot median and variance with ggridges::geom_density_ridges see <https://www.rensvandeschoot.com/tutorials/brms-started/> 
library(ggridges)

# download the Rdata files into your working directory, set your working directory and load them
setwd("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/")
load("size_scgl.Rda") # data converted to yearly transition
load("allsdszs_scgl.Rda") # only individuals that were < 0.5 and considered seedlings
# load("size_scgl1.Rda")

nrow(size_scgl)
names(size_scgl)
```

Store in an R package
```{r}
# I already have a project and a repository
# devtools::create("SeedHarvestModeling")

library(usethis)

# Add R functions
# In project folder, make an integrate.R script to integerate all the functions
usethis::use_vignette("SimulateSeedHarvest")
devtools::document() # to make namespace for each function
```


# Functions     
lifespan to estimate how long lived   
Starts a population of 100 individuals in the seedling or smallest bin; do not start a population in a dormant or seed bank bin  
If you have a matrix where fecundity is measured as seeds entering the seedbank (row 1) and/or seeds germinating (row 2), indicate which rows result in a measure of fecundity 

```{r}

lifespan <- function(nx){
  nclasses=dim(nx)[1]
  vec=c(100,rep(0,(nclasses-1)))
  nx[1,]=0
  jj=1
  while (sum(vec)>1){
    vec=nx%*%vec
    jj=jj+1
  }
  return(jj)
}

# Seeds a population with 100 individuals in the smallest size class, removes the top row (so no more reproduction), and follows the population until all have died. Based on a list of transition matrices (with fecundity rate: Mx, and without fecundity rate included: TMx)
lifespanMPM <- function(Mx, TMx, seedlingBin = 1){
  nclasses=dim(Mx[[1]])[1]
  # add 100 individuals to the smallest non-seedbank category
  vec <- rep(0, nclasses)
  vec[seedlingBin] <- 100
  # remove all fecundity from matrices
  nx <- mapply(function(x,y) x - (x-y), Mx, TMx, SIMPLIFY = FALSE) # keep output as matrices
  # if any transition is 100%
  nx[[1]][nx[[1]] == 1] <- 0.9
  jj=1
  while (sum(vec)>1){
    vec=nx[[sample(1:length(Mx),1)]]%*%(floor(vec)) # randomly sample from the list of matrices with fecundity rate removed
    jj=jj+1
  }
  return(jj)
}


# Generation time in a stage based matrix - Cochran and Ellner 1992; use popbio::generation.time

```


```{r}
AnnualTransition <-function(){
  # above_f <- Mx_list[which(f_all >= mn_f)]  from the SeedHarvestSim function get index of one above 
  # below_f <- Mx_list[which(f_all < mn_f)]   from the SeedHarvestSim function get index of one below
  if(Yr == "Good"){
    Mx_i <- sample(above_f, 1) # randomly sample from the high fecundity transition matrices
  } else {
    Mx_i <- sample(below_f, 1)
  }

  # Freq[] is the likelihood to collect seed in good or bad years
  if(CollectYN == 1){  # yes collect, reduce fecuntity by the year good or bad
    fecundMx <- Mx_list[[Mx_i]] - TMx_list[[Mx_i]] # Subtract the transition matrix (Mx) by the matrix without fecundity rate (TMx) to get only fecundity rate
    fecundMx <- fecundMx - fecundMx*Inten_m[Yr,] # Reduce all fecundity rates by intensity of harvest
    nx <- fecundMx + TMx_list[[Mx_i]] # add the reduced fecundity rates to the transition matrix that lacks the fecundity rate to get new transition matrix
  } else {
      nx <- Mx_list[[Mx_i]]
    }
  K <- 100*StartPopSize  # maximum population size
  if(ddceiling == TRUE & sum(vec[!is.na(Nx_list[[1]])]) >= K*0.9){
    vec.t1 <- floor(nx%*%vec)
    vec <- floor(vec.t1/(lambda(nx))*(1+(lambda(nx)-1)*(1-(sum(vec[!is.na(Nx_list[[1]])])/K ))))  # dominant eigenvalue is lambda and the same as eigen(nx)$values[1]; what now? 1+(lambda(nx)-1) is just lambda(nx)
    } else {
      # Multiply N_t+1 = Matrix*N_t; vec comes from the SeedHarvestSim function
      vec <- floor(nx%*%vec)
    }
  list(vec, lambda(nx), projmat = nx)
}

# starting population of only above ground individuals - pop size is above ground
SeedHarvestSim <- function(Mx_list, TMx_list, Nx, Nx_list, StartPopSize, GoodBadTm, Freq = c(0,0), Int = c(0,0), 
                           TotYrs, ClusteredColl = 1, ddceiling = FALSE){
  # take the distribution of classes (likely the stable stage distribution) and scale to starting population size with integers
  # Scale to starting population size with only the aboveground, detectable stages (no seedbank or dormant); undetectable stages have NA in Nx_list
  Nx_scale <- Nx[!is.na(Nx_list[[1]])]
  # vec <- matrix(floor(Nx*(StartPopSize/sum(Nx))), ncol = 1)
  vec <- matrix(round(Nx*(StartPopSize/sum(Nx_scale)),0), ncol = 1)
  # Annual transition function needs local environment variables
  environment(AnnualTransition) <- environment() 

    # Seed Harvest Rates, frequency, probability of harvest in a given year and intensity or percent of seed harvested
  #     Freq
  #Good X
  #Bad  Y
  # Good vs. bad - either determine the percent per good and bad after given clusters or just keep not in clusters and
  Freq_m <- matrix(Freq, nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Freq")))
  Inten_m <- matrix(Int, nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Inten")))

    # fecundity is the cutoff (practical sense of a good year with lots of seed vs few seed produced) but this doesn't really tell me if there is high production of seed, it's the ratio of recruitment to seed production
  f_all <- apply(mapply(function(x,y) x-y, Mx_list, TMx_list), 2, sum) # subtracting the matrices with fecundity from the matrices with all transitions leaves only the fecundity transitions, adding all remaining fecundity values
  mn_f <- mean(f_all) 
  #The index of above/equal and below average
  above_f <- which(f_all >= mn_f)
  below_f <- which(f_all < mn_f)
  
    # Initialize 
    ceil <- 10*StartPopSize
    Yr <- "Good"
    GBs <- rep(NA,TotYrs)
    Freqs <- rep(NA,TotYrs)
    Intens <- rep(NA,TotYrs)
    PopSize <- rep(NA, TotYrs)
    lambdas <- rep(NA, TotYrs)
    mats <- list()
    yrs <- 1

  # if clustered collection then does not depend on good or bad, will collect during a bad year, all match the larger frequency
  if(ClusteredColl > 1){
    numCollections <- max(Freq)*TotYrs
    numclusters <- floor(numCollections/ClusteredColl) # might underestimate
    i <- 0
    collectionyr_ix <- c()
    notavailable <- c()
    while(i < numclusters){
      available <- setdiff((1:(TotYrs-ClusteredColl)),notavailable) # but need to substract ClusteredColl from each start (clst) 
      clst <- sample(size = 1, x = available) # select from possible non-overlapping starts
      notavailable <- c(notavailable, (clst-ClusteredColl):(clst+ClusteredColl-1))
      collectionyr_ix <- c(collectionyr_ix,c(clst:(clst+ClusteredColl-1)))
      i <- i+1
      if(length(available)<ClusteredColl){
        warning("Cannot find non-overlapping cluster period, set at frequency")
        collectionyr_ix <- c(collectionyr_ix, sample(size = (numCollections-length(collectionyr_ix)), setdiff((1:TotYrs),collectionyr_ix)))
        break
        }
      } # allow adding overlapping cluster periods
    Freqs <- rep(0,TotYrs)
    Freqs[collectionyr_ix] <- 1
    
    while(yrs <= TotYrs){
      # Transition between good and bad years
      Yr <- if(rbinom(1,1,GoodBadTm[Yr,1])==1){
        "Good"
      } else {
          "Bad"
        } # Make next a good or bad year
      
      CollectYN <- Freqs[yrs] # this was in the Annual transition
      onetransition <- AnnualTransition()
      GBs[yrs] <- Yr
      if(CollectYN==1){
        Intens[yrs] <- Inten_m[Yr,]
      }

      PopSize[yrs] <- floor(sum(vec))
      lambdas[yrs] <- onetransition[[2]]
      mats[[yrs]] <- onetransition[[3]]
      yrs <- yrs+1
      }
    } else {
      ######################## Annual Transitions without clusters ######################
      while(yrs <= TotYrs){
        # Transition between good and bad years
        Yr <- if(rbinom(1,1,GoodBadTm[Yr,1])==1){
          "Good"
        } else {
            "Bad"
          } 
        CollectYN <- rbinom(1,1,Freq_m[Yr,]) # this was in the Annual transition
        onetransition <- AnnualTransition()  ### CHECK BACK HERE
        GBs[yrs] <- Yr
        Freqs[yrs] <- CollectYN
        if(CollectYN==1){
          Intens[yrs] <- Inten_m[Yr,]
        }
        
        vec <- onetransition[[1]] 
        PopSize[yrs] <- sum(vec)
        lambdas[yrs] <- onetransition[[2]]
        mats[[yrs]] <- onetransition[[3]]
        yrs <- yrs+1
        }
      } # ends all annual transitions without clusters
    SimDF <- data.frame(GB_yrs = GBs, Frequency = Freqs, Intensity = Intens, PopulationSize = PopSize, Year = 1:TotYrs, 
                        lambdas = lambdas)
    list(SimDF, FreqGB = Freq, IntGB = Int, GBMx = GoodBadTm, StartingPopSize = StartPopSize, Mx = mats,
         LogGrowthRate = stoch.growth.rate(mats, verbose=FALSE)) # $approx is log stochastic growth rate by Tuljapukar's approximation; $sim and CI
}


```


```{r}

# Ellis et al. 2012 paper
tm <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Kaye_transitionmatrices.csv")

table(tm$SPP)
aggregate(SPP ~ POP + YR, data = tm, function(x) length(x))
aggregate(POP ~ YR, data = tm, function(x) length(x))

sp_info <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Kaye_speciesinfo.csv")

m1 <- gsub("\\[|\\]", "", tm$Mx[100]) 
m2 <- strsplit(m1, ";")  # remove the ";" that separates rows
(m3 <- lapply(m2, function(x) strsplit(trimws(x,"l"), " "))) # split each list element after removing leading whitespace
(m4 <- matrix(as.numeric(unlist(m3)), nrow = length(m3[[1]][[1]]), byrow = TRUE))
# Mx: Annual transition matrix
# Tmx: Annual trnasition matrix with transition probabilities, no fecundity
# Nx: Vector of observed stage structures (counts in each stage); must be at the start

# NA for unobserved stages
Nx_all <- lapply(1:nrow(tm), function(i){
  v1 <- gsub("\\[|\\]", "", tm$Nx[i])
  v2 <- sapply(v1, function(x) strsplit(trimws(x,"l"), " ")) 
  v3 <- as.numeric(unlist(v2[[1]]))
  v3
})

#CIPI get rid of the matrix with different number of stages, do that on its own, most have 3, one population has 6, rename species CIPI3 and CIPI6
Nx_names <- lapply(1:nrow(tm), function(i){
  spp <- tm$SPP[i]
  pop <- tm$POP[i]
  yr <- tm$YR[i]
  paste(spp, pop, yr)
})


# Nx_all[grep("CIPI", unlist(Nx_names))][which(sapply(Nx_all[grep("CIPI", unlist(Nx_names))], function(x) length(x))==3)]

# which(sapply(Nx_all[grep("CIPI", unlist(Nx_names))], function(x) length(x))==3)
# which(sapply(Nx_all[grep("CIPI", unlist(Nx_names))], function(x) length(x))==6)

Nx_names[grep("CIPI", Nx_names)][1:30] <- str_replace_all(Nx_names[grep("CIPI", Nx_names)][1:30], "CIPI", "CIPI3")
Nx_names[grep("CIPI", Nx_names)][31:35] <- str_replace_all(Nx_names[grep("CIPI", Nx_names)][31:35], "CIPI", "CIPI6")

Nx_all[grep("CIPI3", unlist(Nx_names))]
Nx_all[grep("CIPI6", unlist(Nx_names))]

tm$SPP <- as.character(tm$SPP)
tm$SPP[grep("CIPI", tm$SPP)][1:30] <- "CIPI3"
tm$SPP[grep("CIPI", tm$SPP)][31:35] <- "CIPI6"
tm$SPP <- as.factor(tm$SPP)

names(Nx_all) <- Nx_names

# Transitions without fecundity
TMx_all <- sapply(1:nrow(tm), function(i){
  m1 <- gsub("\\[|\\]", "", tm$Tmx[i])
  m2 <- strsplit(m1, ";")  # remove the ";" that separates rows
  m3 <- lapply(m2, function(x) strsplit(trimws(x,"l"), " ")) # split each list element after removing leading whitespace
  m4 <- matrix(as.numeric(unlist(m3)), nrow = length(m3[[1]][[1]]), byrow = TRUE)
  m4
}, simplify =FALSE, USE.NAMES = TRUE)


#CIPI get rid of the matrix with different number of stages, do that on its own, most have 3, one population has 6, rename species CIPI3 and CIPI6
# TMx_all[grep("CIPI", unlist(Nx_names))][which(sapply(TMx_all[grep("CIPI", unlist(Nx_names))], function(x) dim(x))[1,]==3)]
# which(sapply(TMx_all[grep("CIPI", unlist(Nx_names))], function(x) dim(x))[1,]==3)
# which(sapply(TMx_all[grep("CIPI", unlist(Nx_names))], function(x) dim(x))[1,]==6)
# Nx_names[grep("CIPI", Nx_names)][1:30] <- str_replace_all(Nx_names[grep("CIPI", Nx_names)][1:30], "CIPI", "CIPI3")
# Nx_names[grep("CIPI", Nx_names)][31:35] <- str_replace_all(Nx_names[grep("CIPI", Nx_names)][31:35], "CIPI", "CIPI6")
# TMx_all[grep("CIPI3", unlist(Nx_names))]
# TMx_all[grep("CIPI6", unlist(Nx_names))]

names(TMx_all) <- Nx_names

sp_info$SPP <- as.character(sp_info$SPP)
sp_info <- rbind(sp_info, sp_info[sp_info$SPP == "CIPI",])
sp_info$SPP[sp_info$SPP == "CIPI"][1] <- "CIPI3" 
sp_info$SPP[sp_info$SPP == "CIPI"] <- "CIPI6" 


# Transitions and fecundity
Mx_all <- sapply(1:nrow(tm), function(i){
  m1 <- gsub("\\[|\\]", "", tm$Mx[i])
  m2 <- strsplit(m1, ";")  # remove the ";" that separates rows
  m3 <- lapply(m2, function(x) strsplit(trimws(x,"l"), " ")) # split each list element after removing leading whitespace
  m4 <- matrix(as.numeric(unlist(m3)), nrow = length(m3[[1]][[1]]), byrow = TRUE)
  m4
}, simplify =FALSE, USE.NAMES = TRUE)

names(Mx_all) <- Nx_names
Mx_all[grep("CIPI", names(Mx_all))]

lambdas <- sapply(Mx_all, function(x) lambda(x), simplify = FALSE, USE.NAMES = TRUE)

fecundity <- mapply(function(x,y){ 
  fec <- x-y
  rowSums(fec)[1] #Only the first row is funcunity across classes (subtracted out survival by Mx-TMx)
  }, Mx_all, TMx_all)

x <- unique(tm$SPP)[3]

```

To create a generation time function
```{r}
library(matlib)

# Identity matrix
I <- diag(length(Nx_all[[1]]))
# Inverse matrix exists when det(A) != 0
if(det(Mx_all[[1]]) != 0) AI <- inv(Mx_all[[1]])
Mx_all[[1]]
TMx_all[[1]]
AI
# 
eigen(Mx_all[[1]])
# Asymptotic growth rate
lambda(Mx_all[[1]])
# stable stage distribution (w: right eigen vector)
stable.stage(Mx_all[[1]])
# Relative contribution of individuals in each stage to future population growth (v: left eigenvector)
# Arabis fecunda stage 4 reproduces into any of the stage classes, transitions from any size to another
reproductive.value(Mx_all[[1]])


Nx_names[[100]] # Dicerandra frutescens
eigen(Mx_all[[100]])
lambda(Mx_all[[100]])
stable.stage(Mx_all[[100]])
reproductive.value(Mx_all[[100]]) # seedbank, seedlings, small, flowering sm, med fl, large fl
generation.time(Mx_all[[100]])

# Life history traits from stage based matrices; all will differ for different newborn types, none depend on stable stage
# P_x: discrete survivorship function
# expected remaining life-span of an individual in stage i
# mean age at maturity
# f_x: discrete maternity function
# R_o: net reproductive rate

```

```{r}
# how would I expect species to respond to pop size and harvest?   
toplotall <- c()
sp <- "ARFE"
for(w in 1:14){
    Mx <- Mx_all[grep(sp, unlist(Nx_names))][[w]]
    TMx <-  TMx_all[grep(sp, unlist(Nx_names))][[w]]
    # three veg and one repro class, recruits in any class
    print(w)
    print(fecundMx <- Mx - TMx)   
    i <- 0.5
    print(fecundMx <- fecundMx - fecundMx*i)
    print(nx <- fecundMx + TMx);Mx
    print(lambda(nx))
    print(lambda(Mx)) # latter should be larger than prior
}


for(sp in unique(tm$SPP)){
  densityNoharvest <- unlist(lapply(Mx_all[grep(sp, unlist(Nx_names))], function(x) lambda(x)))
  densityHarvest <- do.call(rbind,lapply(seq(0.1,1,by=0.1), function(i){
    densityHarvest <- unlist(mapply(function(Mx, TMx){
      fecundMx <- Mx - TMx # Subtract the transition matrix (Mx) by the matrix without fecundity rate (TMx) to get only fecundity rate
      fecundMx <- fecundMx - fecundMx*i # Reduce all fecundity rates by intensity of harvest
      nx <- fecundMx + TMx # add the reduced fecundity rates to the transition matrix that lacks the fecundity rate to get new transition matrix)))
      lambda(nx)
    }, Mx_all[grep(sp, unlist(Nx_names))], TMx_all[grep(sp, unlist(Nx_names))]))
    data.frame(lambdas = densityHarvest, Intensity = i) 
  }))
  
  addplotall <- rbind(data.frame(SPP = sp, densityHarvest), data.frame(SPP = sp, lambdas = densityNoharvest, Intensity = 0))
  toplotall <- rbind(toplotall, addplotall)
}


ggplot(toplotall[toplotall$SPP == "ARFE",], aes(lambdas, colour = as.factor(Intensity)))+
  geom_density()+
  # geom_histogram(colour = rgb(1,1,1,0.5),position="dodge")+ # scale_fill_hue
  theme_bw()+
  facet_wrap(~SPP, scales = "free")+
  scale_colour_hue(l = 40, c = 80) #, h.start = 10


```



# Matrix Population Models    
Annuals
```{r}
load("C:/Users/deprengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/PVA/Paniw etal/patterns_temporal_autocorrelation-master/COMPADRE_v.4.0.0.RData")

# str(compadre[[1]]) # $Ecoregion
# str(compadre[[2]]) # split into 'prop' as seed or undetectable vs. 'active' for above ground, description of each class, number of classes
# str(compadre[[3]]) # each is a list of 4: the matA (average), matU only surivval-dependent demographic processes (seed bank, statis, progression, retrogression, vegetitative dormancy), matF for fecundity, matC (clonal reproduction)

# $ SpeciesAuthor is the taxonomic name from author, and the name from The Plant List $SpeciesAccepted could check $SpeciesAccepted against status

annuals <- compadre[[1]][grep("Annual", compadre[[1]]$OrganismType),]
# write.csv(annuals, file = "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/compadre_annuals.csv")

bofe <- compadre[[1]][grep("Arabis", compadre[[1]]$SpeciesAuthor),c(1:2,5,10,13:15,17:24,27:31,33,35:36,38,41,46:47)]
nrow(bofe)
length(Nx_all[grep("ARFE", unlist(Nx_names))])
sp_info[,c(1:3,13:17)]

AEVI <- compadre$mat[compadre$metadata$Genus == "Aeschynomene"]
# matU is survival matrix
# matF fecundity
# matC clonal

compadre$metadata[compadre$metadata$Genus == "Aeschynomene",]
lapply(AEVI, function(x) x$matA)
AEVI[[1]]$matU + AEVI[[1]]$matF

sp_info[2,]
# sp_info <- rbind(sp_info, c("AEVI","Aeschynomene","virginica","Fabaceae","Ecol Appl 2005",
#                             "Griffith; Forseth","patrick@montgomerybotanical.org","","",1,
#                             "1998-2000",4,"wetland","","annual","herbaceous","semelparous","yes","no",6,2))
# 
Nx_names_AEVI <- list("AEVI AEVI_1", "AEVI AEVI_2", "AEVI AEVI_2")
Nx_all_AEVI <- list(c(NA,NA,1,1,1), c(NA,NA,1,1,1), c(NA,NA,1,1,1)) # Don't know but only need which are NA - unobserved seedbank
Mx_all_AEVI <- list(lapply(AEVI, function(x) x$matA))
TMx_all_AEVI <- list(lapply(AEVI, function(x) x$matU))


# Thorpe and Kaye 2008 mean matrices for each year  
# SEER parameter estimation (2) almost matches recruits/plant and recruits/seed but not quite
Nx_names_SEER <- list("SEER 2004", "SEER 2005", "SEER 2006", "SEER 2007") 
Nx_all_SEER <- list(c(NA,1),c(NA,1),c(NA,1),c(NA,1)) # I have the number per population and the average but don't need
Mx_all_SEER <- list(matrix(c(0.409,10.667,0.026,1.47), ncol = 2, byrow = TRUE),
                    matrix(c(0.409,2.532,0.006,0.25), ncol = 2, byrow = TRUE),
                    matrix(c(0.409,1.244,0.011,2.14), ncol = 2, byrow = TRUE),
                    matrix(c(0.409,4.95,0.001,0.03), ncol = 2, byrow = TRUE))
TMx_all_SEER <- list(matrix(c(0.409,0,0.026,0), ncol = 2, byrow = TRUE),
                    matrix(c(0.409,0,0.006,0), ncol = 2, byrow = TRUE),
                    matrix(c(0.409,0,0.011,0), ncol = 2, byrow = TRUE),
                    matrix(c(0.409,0,0.001,0), ncol = 2, byrow = TRUE))


```


```{r}

# Enter plants in first observed stage
seedlingbins <- data.frame(SPP = unique(tm$SPP), 
                           seedlingBin = do.call(rbind,lapply(Nx_all[!duplicated(tm$SPP)], function(x){
                                           if(length(which(is.na(x[1])))==0){
                                             1
                                             } else {
                                               which(is.na(x[1]))+1
                                               }
                             })))

lifelengthsXmatrix <- do.call(rbind,lapply(1:length(Mx_all), function(i){
  data.frame(Lifespan = lifespanMPM(Mx_all[i], TMx_all[i], 
                                    seedlingbins$seedlingBin[seedlingbins$SPP == strsplit(Nx_names[[i]][1]," ")[[1]][1] ]),
             SPP = strsplit(Nx_names[[i]][1]," ")[[1]][1], Site = strsplit(Nx_names[[i]][1]," ")[[1]][2],
             Yr =  strsplit(Nx_names[[i]][1]," ")[[1]][3])
}))

generationtimeXspecies <- do.call(rbind,lapply(sp_info$SPP, function(sp){
  matF <- lapply(1:length(grep(sp, Nx_names)), function(x){ 
    Mx_all[grep(sp, Nx_names)][[x]] - TMx_all[grep(sp, Nx_names)][[x]]
    })
  data.frame(generationTime = generation.time(mean(Mx_all[grep(sp, Nx_names)]),
                                              r = mean(matF)), 
             SPP = sp)
}))

avg.lifespan.sp <- aggregate(Lifespan~SPP,data = lifelengthsXmatrix, median)
sd.lifespan.sp <- aggregate(Lifespan~SPP,data = lifelengthsXmatrix, sd)

lifespan.sp <- cbind(avg.lifespan.sp, SDlifespan = sd.lifespan.sp[,2])
lifespan.sp[order(lifespan.sp$Lifespan),]

lifelengthsXmatrix[lifelengthsXmatrix$SPP == "NEMA",]

lifespan.sp <- merge(lifespan.sp, generationtimeXspecies, by = "SPP")

```


Examples from Ellis et al. 2012    
Arabis fecunda: "Entries in the fecundity matrix were calculated by dividing the number of recruits in a particular stage class by the number of flowering plants the previous year."   Lesica and Shelly 1995 "Demography of Arabis fecunda"
    1. Matrices are labeled 1987 to 1992
    2. Matrix ARFE_Charleys 1987 was measured in 1987 = t and 1988 =t+1 while '1988' is 1988 = t and 1989 = t+1 until 1993 
    3. They estimated seed per fruit for each population each year except 1992
    4. transition probabilities were N_t per class (i) that moved to class (j) over one year N_t+1 divided by the number of plants in class (i) N_t
    5. Reproductive plants can transition among all size classes and seperately can reproduce, these are added in the transition matrix
    6. Recruitment rate = (new recruits in t+1)/(survivors from t); recruits can appear in one or more classes and in any class including reproductive
    7. Number of seed/fruit varied 30.9, 32.4, 34 for Charles Gulch, Lime Gulch, and Vipond Park. Number of fruit per plant varied by year and site

Fecundity alone and then find the number of new recruits? No, can't get that from transition, it is summarized as #new recruits_t+1 / #survivors 
```{r}
TMx_fecundity <- lapply(unique(tm$SPP), function(sp){
  Tx_sp <- TMx_all[grep(sp, unlist(Nx_names))]
  Mx_sp <- Mx_all[grep(sp, unlist(Nx_names))]
  fecundity_sp <- mapply(function(x,y)x-y, Mx_sp, Tx_sp, SIMPLIFY = FALSE)
  fecundity_sp
})


TMx_fecundity[[5]]


```

# save lists to share with CPC group and possible as examples in R package
```{r}
# save(Nx_all, file = "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Nx_all.Rda")
# 
# save(TMx_all, file = "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/TMx_all.Rda")
# 
# save(Mx_all, file = "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Mx_all.Rda")

```


# Fecundity     
Defining a good and bad year as higher than or lower than average fecundity means what for overall growth rate, other life-cycle parameters?     

```{r}
# Is fecundity correlated to lambda
all_summarydata <- data.frame(SPPSiteYr = names(lambdas), SPP = tm$SPP, lmbd = unlist(lambdas), f = unlist(fecundity))
all_summarydata <- merge(all_summarydata, sp_info, by = "SPP")

# for which are fecundity and lambda correlated
lm1 <- lm(lmbd ~ f, data = all_summarydata)
lm2 <- lm(lmbd ~ f * Genus, data = all_summarydata)
lm3 <- lm(lmbd ~ f * Number.of.stages, data = all_summarydata)

lm.list <- list(lm1, lm2, lm3)
lm.names <- as.character(unlist(lapply(lm.list, formula)))
(lm.results <- aictab(lm.list, modnames = lm.names))

# evidence ratio
for(i in 2:length(lm.list)){
  print(exp(0.5*lm.results$Delta_AICc[i]))
}

summary(lm2)

# fecundity doesn't vary for some. 
ggplot(all_summarydata, aes(f, lmbd, colour = Genus))+
  geom_point()+
  stat_smooth(method = "lm")+
  theme_bw()+
  facet_wrap(~Genus, scales="free")+
  theme(legend.position="none")+
  ylab("lambda")+
  xlab("fecundity")
```


# Simulations
## Test output for one species - Dicerandra frutescens (Ellis et al. 2012). Lamiaceae, short lived <10 years (lifespan function estimated 10 years),
iteroparous perennial. Post-fire population had positive growth, 6+ years since fire declining

# start with one species
Arabis fecunda - short lived, no seed bank, no dormancy, fecundity are number of recruits in a stage class by the number of flowering plants the previous year
```{r}

pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Simulation_output/"

# to accommodate annuals and addition species to the Ellis paper
# lifespan is really generation time
SimSimple <- function(HarvestType = "No", sppVector = unique(tm$SPP), FrG = 0, FrB = 0, intG = 0, intB = 0, 
                      AvgInt = 0, Cgg_gb_bg_bb = c(0.5,0.5,0.5,0.5), reps = 100, Mxs, TMxs, Nxs,
                      Simlength = 50*(floor(lifespan.sp$generationTime[lifespan.sp$SPP==sp])), 
                      lifespan = floor(lifespan.sp$generationTime[lifespan.sp$SPP==sp])){
  lapply(sppVector, function(sp){
    bypopsz <- do.call(rbind,lapply(c(10,50,100,500), function(popsz){
      outdf <- do.call(rbind,lapply(1:reps, function(repNow){
        outSimulation <- SeedHarvestSim(Mx_list = Mxs,
                                        TMx_list = TMxs,
                                        Nx_list = Nxs,
                                        Nx = stable.stage(mean(Mxs)),
                                        StartPopSize = popsz,
                                        GoodBadTm = matrix(Cgg_gb_bg_bb, 
                                                           nrow=2, byrow = TRUE, 
                                                           dimnames = list(c("Good","Bad"),
                                                                           c("Good","Bad"))),
                                        Freq = c(FrG,FrB), Int = c(intG,intB), 
                                        TotYrs = Simlength,
                                        ClusteredColl = 1, # clust,
                                        ddceiling = FALSE)
        # save(outSimulation, file = paste(pathstart,HarvestType,"Harvest_",sp,"PopSz",popsz,"Rep",rep,
        #                                  "Fr",FrG,"_",FrB,"In",intG,"_",intB,"AverageInt",AvgInt,
        #                                  "Climate",paste(Cgg_gb_bg_bb, collapse = "_"),
        #                                  ".Rdata", sep=""))
        # Damping ratio
        AMx <- mean(outSimulation[[6]])
        dampR <- eigen(AMx)$values[1]/abs(eigen(AMx)$values[2])
        
        outSimulation[[1]]$Rep <- repNow
        outSimulation[[1]]$SPP <- sp
        if(any(outSimulation[[1]]$PopulationSize==0)){
          Exterpated <- 1
          Time2Ext <- which(outSimulation[[1]]$PopulationSize == 0)[1]
        } else {
          Exterpated <- 0
          Time2Ext <- NA
        }
        
        # Extinction probability, stochastic lambda, and damping ratio
        out <- data.frame(Tulapprox = outSimulation$LogGrowthRate$approx,
                          LogGrowthSim = outSimulation$LogGrowthRate$sim,
                          Exterpated, Time2Ext, 
                          DampingRatio = as.numeric(dampR),
                          FreqG = FrG, FreqB = FrB, 
                          IntG = intG, IntB = intB,
                          SPP = sp, Clust = 1, StPopSz = popsz, 
                          lifespan = lifespan,
                          Frequency = 0, IntRatio = 0)# Int[1]/Int[2])
        rm(outSimulation)
        out
      })) # end replicates
      outdf
    })) # end bypopsz 
    # bypopsz
    save(bypopsz, file = paste(pathstart, HarvestType,"Harvest",
                               "Fr",FrG,"_",FrB,"In",intG,"_",intB,"AverageInt",AvgInt,
                               "Climate",paste(Cgg_gb_bg_bb, collapse = "_"),sp,
                               ".Rdata", sep=""))
  }) # end species
}

```

Figures pre-harvest conditions
```{r}
# SimSimple(HarvestType = "No", sppVector = unique(tm$SPP)[1:3], reps = 10)

# load to bind and plot
HarvestType <- "No"
files <- list.files(path = pathstart, pattern = paste(HarvestType, "Harvest", sep=""))
toplotNo <- do.call(rbind, lapply(files, function(x){
  load(file = paste(pathstart,x,sep = ""))
  bypopsz
  }))

model <- glm(DampingRatio ~ lifespan, data = toplotNo, family = poisson)
summary(model)
# 
DRpNo <-
ggplot(toplotNo, aes(lifespan, DampingRatio))+ #
  geom_jitter(height = 0, width = 1, alpha = 0.04, shape = 20)+
  # stat_smooth(method = "glm", family = "quasipoisson", formula = y ~ ns(x, 3))+
  # geom_smooth(method = MASS::glm.nb, aes(color = "NB"), se = FALSE)+
  geom_line(aes(y=fitted(model)))+
  theme_bw()+
  ylab("Damping Ratio")+
  xlab("Generation Time")
 
ggsave(filename = "C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3/Figures/DampingRatioNoharvest.jpg", DRpNo,
           width=100, height=100,units='mm', dpi=300)

# , colour = as.factor(StPopSz)
ggsave(filename = "C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3/Figures/StochLambdaNoharvest.jpg",
       ggplot(toplotNo, aes(lifespan, Tulapprox ))+
         geom_jitter(height = 0, width = 0.5, alpha = 0.4, shape = 20)+
         stat_smooth(method = "glm")+
         theme_bw()+
         ylab("Log stochastic growth rate \n (Tuljapukar's approximation)")+
         xlab("Generation Time"), width=100, height=100,units='mm', dpi=300)
# 
ggsave(filename = "C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3/Figures/Time2ExtNoharvest.jpg",
       ggplot(toplotNo, aes(as.factor(StPopSz), Time2Ext))+
         geom_boxplot()+
         theme_bw()+
         facet_wrap(~SPP, scales = "free")+
         geom_jitter(height=0, width = 0.01)+
         ylab("Time to extinction (< 1)")+
         xlab("Starting population size"), width=300, height=300,units='mm', dpi=300)


extinctionrisk <- aggregate(Exterpated ~ SPP + StPopSz + FreqG + FreqB + IntG + IntB + lifespan, function(x) sum(x)/length(x) ,data =  toplotNo)

ggsave(filename = "C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3/Figures/ExtRiskNoharvest.jpg",
ggplot(extinctionrisk, aes(lifespan, Exterpated))+
  # geom_smooth(method=MASS::glm.nb, se = FALSE)+
  stat_smooth(method="glm", family="binomial", formula=y~log(x),se=FALSE)+
  theme_bw()+
  facet_wrap(~as.factor(StPopSz))+
  geom_point()+
  xlab("Generation Time")+
  ylab("Extinction Risk"),
           width=100, height=100,units='mm', dpi=300)

```

# seed collection only in good years   Pre-2020.11.15
Old version, add levels between 0.1, 0.25, 0.5, 0.75, 0.9 as needed   
Best to run on desktop, not on laptop
```{r}

# pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Simulation_output/"
# 
# # ONly got through GEPN for Freq 0.2, Int 0.2. Might need to do fewer
# 
# #Intensity of 0.1 to 1; Frequency 0.1 to 0.9: wouldn't ever do 100 of seed 100 of the time
# lapply(seq(0.1,1, by = 0.1), function(intG){
#   lapply(seq(0.1,1, by = 0.1), function(FrG){
#   SimSimple(HarvestType = "GoodYrOnly", sppVector = unique(tm$SPP), intG = intG, FrG = FrG )
#   })
#   })

```


# Figures   
Plot Equal harvest compared to no harvest   
```{r}
HarvestType <- "SameGB"
files <- list.files(path = pathstart, pattern = paste(HarvestType, "Harvest", sep=""))
files <- files[!grepl("SameGBHarvestFr0.75_0In", files)] # accidentally made some called Same but not same
files <- files[!grepl("SameGBHarvestFr0.5_0In", files)] # accidentally made some called Same but not same
files <- files[!grepl("SameGBHarvestFr0.25_0In", files)] # accidentally made some called Same but not same
files <- files[!grepl("SameGBHarvestFr0.1_0In", files)] # accidentally made some called Same but not same

toplot <- do.call(rbind, lapply(files, function(x){
  load(file = paste(pathstart,x,sep = ""))
  bypopsz
}))

filesNoHarvest <- list.files(path = pathstart, pattern = "NoHarvest")
toplotNoharvest <-  do.call(rbind, lapply(filesNoHarvest, function(x){
  load(file = paste(pathstart,x,sep = ""))
  bypopsz
}))
toplot <- rbind(toplot, toplotNoharvest)
table(toplot$IntG, toplot$FreqG, toplot$SPP)
head(toplot) # Note that 'lifespan' really means generation time

filesNoHarvest[grep("SEER", filesNoHarvest)]
files[grep("SameGBHarvestFr0.75_0In", files)]


toplot$LifeHistory <- "Annual"
toplot$LifeHistory[toplot$lifespan > 1] <- "Short-lived perennial"
toplot$LifeHistory[toplot$lifespan >= 10] <- "Long-lived perennial"
table(toplot$LifeHistory)
toplot$LifeHistory <- factor(toplot$LifeHistory, levels = c("Annual","Short-lived perennial","Long-lived perennial"))

# all values as standardized mean difference from no harvest or the z-score of everyone from no harvest
names(toplot)


ggplot(toplot, aes(lifespan, DampingRatio, colour = as.factor(StPopSz )))+
  geom_point()+
  stat_smooth()

# ------------------------------------- Z-score -----------------------------------
# Stochastic lambda not changing by population starting size
for(sp in unique(toplot$SPP)){
  toplot$TulapproxSMD[toplot$SPP == sp  ] <- (toplot$Tulapprox[toplot$SPP == sp  ]-mean(toplot$Tulapprox[toplot$FreqG == 0 & toplot$FreqB == 0 & toplot$SPP == sp  ]))/sd(toplot$Tulapprox[toplot$FreqG == 0 & toplot$FreqB == 0 & toplot$SPP == sp  ])
}

# Does change with pop size!
for(sp in unique(toplot$SPP)){
  for(stsz in unique(toplot$StPopSz)){
    toplot$Time2ExtSMD[toplot$SPP == sp & toplot$StPopSz] <- (toplot$Time2Ext[toplot$SPP == sp & toplot$StPopSz]-mean(toplot$Time2Ext[toplot$FreqG == 0 & toplot$FreqB == 0 & toplot$SPP == sp & toplot$StPopSz]))/sd(toplot$Time2Ext[toplot$FreqG == 0 & toplot$FreqB == 0 & toplot$SPP == sp & toplot$StPopSz])
  }
}


# ------------------------------------ Effect size -----------------------------------
# Effect size is the change in correlation coefficient (r^2) (change in r^2)/(1-r^2 of full model)
# <https://stats.stackexchange.com/questions/95054/how-to-get-an-overall-p-value-and-effect-size-for-a-categorical-factor-in-a-mi> 
# LifeHistory offset is 
glm1 <- lmer(TulapproxSMD ~ IntG + FreqG + (1|SPP), data = toplot)
glm2 <- lmer(TulapproxSMD ~ IntG + FreqG + (1|LifeHistory), data = toplot)
glm3 <- lmer(TulapproxSMD ~ IntG + FreqG + LifeHistory + (1|SPP), data = toplot)

summary(glm2)
summary(glm3)

# Effect size
r2.corr.mer <- function(m) {
  lmfit <-  lm(model.response(model.frame(m)) ~ fitted(m))
  summary(lmfit)$r.squared
}

r2.corr.mer(glm1)
1-var(residuals(glm1))/(var(model.response(model.frame(glm1))))

# ---------------------------------------------------------------------------------------

StochLamNo <- ggplot(toplot, aes(IntG, TulapproxSMD,colour = as.factor(FreqG)))+ # fill = as.factor(FreqG), group = as.factor(FreqG),
    # geom_boxplot(position = position_dodge2())+ 
    geom_point(position = position_jitterdodge(dodge.width = 0.05), alpha = 0.1)+
    stat_smooth(method = "glm", se = FALSE)+
    theme_bw()+
    facet_wrap(~SPP, scales = "free_y", ncol = 3)+ 
    ylab("Log stochastic growth rate \n (Z-score of Tuljapukar's approximation)")+
    xlab("Harvest intensity")+
    scale_color_discrete(name = "Harvest \n frequency")
  
ggsave(filename = "C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3/Figures/StochLambda.jpg", StochLamNo,
         width=275, height=300,units='mm', dpi=300)

ggsave(filename = "C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3/Figures/StochLambda_v2.jpg", 
       ggplot(toplot, aes(FreqG, Tulapprox, colour = as.factor(IntG)))+ # , group = as.factor(IntG)
          # geom_boxplot(position = position_dodge(width = 0.04))+
          geom_point(position = position_jitterdodge(dodge.width = 0.05), alpha = 0.1, shape = 20)+
          stat_smooth(method = "glm", se = FALSE)+
          theme_bw()+
          facet_wrap(~SPP, scales = "free_y", ncol = 3)+ 
          ylab("Log stochastic growth rate \n (Z-score of Tuljapukar's approximation)")+
          xlab("Harvest frequency")+
          scale_color_discrete(name = "Harvest \n intensity"), 
   width=275, height=300,units='mm', dpi=300)



ggsave(filename = "C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3/Figures/StochLambda_v3.jpg", 
       ggplot(toplot, aes(IntG, TulapproxSMD, colour = as.factor(FreqG)))+ # , group = as.factor(IntG)
          # geom_boxplot(position = position_dodge(width = 0.04))+
          geom_point(position = position_jitterdodge(dodge.width = 0.05), alpha = 0.1, shape = 20)+
          stat_smooth(method = "glm", se = FALSE)+
          theme_bw()+
          facet_wrap(~LifeHistory, scales = "free_y", ncol = 3)+ 
          ylab("Log stochastic growth rate \n (Z-score of Tuljapukar's approximation)")+
          xlab("Harvest frequency")+
          scale_color_discrete(name = "Harvest \n intensity"), 
   width=300, height=100,units='mm', dpi=300)


# Time to extinction
for(sz in unique(toplot$StPopSz)){
  ggsave(filename = paste("C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3/Figures/Time2Ext",sz,".jpg",sep=""),
         ggplot(toplot[toplot$StPopSz == sz,], aes(FreqG, Time2ExtSMD, colour = as.factor(IntG)))+
           geom_point(position = position_jitterdodge(dodge.width = 0.05), alpha = 0.1, shape = 20)+
           stat_smooth(method = "glm", se = FALSE)+
           theme_bw()+
           facet_wrap(~LifeHistory, scales = "free_y", ncol = 3)+ 
           ylab("Time to extinction (< 1) \n Z-score")+
           xlab("Harvest frequency"), 
   width=300, height=300,units='mm', dpi=300)
}


for(sz in unique(toplot$StPopSz)){
  ggsave(filename = paste("C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3/Figures/Time2ExtXspp",sz,".jpg",sep=""),
         ggplot(toplot[toplot$StPopSz == sz,], aes(FreqG, Time2ExtSMD, colour = as.factor(IntG)))+
           geom_point(position = position_jitterdodge(dodge.width = 0.05), alpha = 0.1, shape = 20)+
           stat_smooth(method = "glm", se = FALSE)+
           theme_bw()+
           facet_wrap(~SPP, scales = "free_y", ncol = 3)+ 
           ylab("Time to extinction (< 1) \n Z-score")+
           xlab("Harvest frequency"), 
   width=300, height=300,units='mm', dpi=300)
}


extinctionrisk <- aggregate(Exterpated ~ SPP + StPopSz + FreqG + FreqB + IntG + IntB + lifespan, function(x) sum(x)/length(x) ,data = toplot)

ggsave(filename = "C:/Users/DePrengm/OneDrive - Denver Botanic Gardens/P drive/My Documents/UCDenver_phd/Dissertation/Chapter3/Figures/ExtRisk.jpg",
       ggplot(extinctionrisk, aes(lifespan, Exterpated))+
         # geom_smooth(method=MASS::glm.nb, se = FALSE)+
         stat_smooth(method="glm", formula=y~log(x),
                     alpha=0.2, size=0.2, se=FALSE)+
         theme_bw()+
         facet_wrap(~as.factor(StPopSz))+
         geom_point()+
         xlab("Generation Time")+
         ylab("Extinction Risk"),
       width=100, height=100,units='mm', dpi=300)
```



Unequal harvest

# Figures 
```{r}

pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Simulation_output/"

# load to bind and plot
HarvestType <- "GoodYrOnly"
# HarvestType <- "BiasAvg"
toplot <- do.call(rbind, lapply(unique(tm$SPP), function(sp){
  files <- list.files(path = pathstart, pattern = paste(HarvestType, "Harvest", sp, sep=""))
  out <- do.call(rbind, lapply(files, function(x){
    load(file = paste(pathstart,x,sep = ""))
    bypopsz
  }))
}))

# Bias Intensity, Frequency same
# sometimes zero
toplot$gbIntBias <- (toplot$IntG+0.00001)/(toplot$IntB+0.00001)
ggplot(toplot, aes(gbIntBias, DampingRatio, colour = as.factor(StPopSz)))+
  theme_bw()+
  facet_wrap(~SPP)+
  geom_point()+
  stat_smooth()

ggplot(toplot, aes(gbIntBias, Tulapprox, colour = as.factor(StPopSz)))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP)

ggplot(toplot[!is.na(toplot$Time2Ext),], aes(as.factor(StPopSz), Time2Ext, colour = as.factor(FreqG)))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP)

extinctionrisk <- aggregate(Exterpated ~ SPP + StPopSz + FreqG + FreqB + IntG + IntB + generationTime, function(x) sum(x)/length(x) ,data = toplot)

ggplot(extinctionrisk, aes(lifespan, Exterpated, colour = as.factor(FreqG)))+
  stat_smooth(method = 'lm')+
  theme_bw()+
  facet_wrap(~as.factor(StPopSz))
geom_point()

# GoodYrOnly
table(toplot$FreqG, toplot$IntG)
ggplot(toplot, aes(as.factor(StPopSz), DampingRatio, colour = as.factor(FreqG)))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP, scales = "free")
  #+
  # geom_jitter(height=0, width = 0.01)

ggplot(toplot, aes(as.factor(StPopSz), Tulapprox, colour = as.factor(FreqG), fill = as.factor(IntG)))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP, scales = "free")

toplot$gFreq2Int <- toplot$FreqG/toplot$IntG

ggplot(toplot, aes(as.factor(gFreq2Int), Tulapprox, colour = as.factor(StPopSz)))+
  # geom_boxplot()+
  theme_bw()+
  geom_point()+
  geom_smooth()+
  facet_wrap(~SPP, scales = "free")+
  geom_jitter(height = 0, width = 0.1)

ggplot(toplot[!is.na(toplot$Time2Ext),], aes(as.factor(StPopSz), Time2Ext, colour = as.factor(FreqG)))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~SPP)

extinctionrisk <- aggregate(Exterpated ~ SPP + StPopSz + FreqG + FreqB + IntG + IntB + lifespan, function(x) sum(x)/length(x) ,data = toplot)

ggplot(extinctionrisk, aes(lifespan, Exterpated, colour = as.factor(FreqG)))+
  stat_smooth(method = 'lm')+
  theme_bw()+
  facet_wrap(~as.factor(StPopSz))
geom_point()

```










# ------------------------------------ Stochastic lambda ---------------------------
1. Tuljapurkar's approximation method and 
2. simulation-based projection over many time steps
Dan Doak: geometric mean = prod(lambdas)^(1/years) or (vector(_t+n)/sum(start vector))^1/n
```{r}

sp <- "TRGR"
# All lambdas per matrix
x <- sapply(Mx_all[grep(sp, unlist(Nx_names))], lambda)

stchgr <- stoch.growth.rate(Mx_all[grep(sp, unlist(Nx_names))], maxt = 100)
log(prod(sample(x, 100, replace = TRUE))^(1/100))
log(mean(sample(x, 100, replace = TRUE)))
# back transformed Tuljapukar's approximation
exp(stchgr$approx)
# stochastic from simulation
exp(stchgr$sim)
exp(stchgr$sim.CI)

# arithmetic mean
mean(x)
# geometric mean
exp(mean(log(x)))
prod(x)^(1/length(x)) # Same!!
# asymptotic lambda for the mean matrix
lambda(mean(Mx_all[grep(sp, unlist(Nx_names))]))
mean(x)

x <- matrix(x, )

```



```{r}
resultpathharvest <- list.files(path = pathstart, 
                         pattern = "DDFALSE",
                         full.names = TRUE)

summary_time2ext <- do.call(rbind,lapply(resultpathharvest, function(xfile){
  load(xfile)
  toplotall <- do.call(rbind,lapply(1:4, function(i){
    freqSameInt <- strsplit(xfile, "Freq")[[1]][2]
    FreqN <- strsplit(freqSameInt, "SameInt")[[1]][1]
    IntN <- strsplit(freqSameInt, "SameInt")[[1]][2]
    toplot <- do.call(rbind, lapply(bypopsz[[i]], function(x){
      data.frame(PopulationStart = popsz[i], Freq=FreqN, 
                 Int = IntN, Time2Ext = x[[2]][which(x[[2]]$PopulationSize == 0)[1],],
                 x[[1]])
      }))
    data.frame(toplot, ExtinctionRisk = sum(toplot$Exterpated)/100)
  }))
  }))

# PCA (or really rda: redundancy analysis) for growth rate, time to extinction, lifespan, extinction risk, frequency, intentisty (eventually IntRatio, cluster), could do Family, Biome, iteroparous 
library(vegan)

require(AICcmodavg)
require(lme4)

allSPP <- merge(summary_time2ext, sp_info, by.x = "Time2Ext.SPP", by.y = "SPP")
allSPP <- merge(allSPP, lifespan.sp, by = "SPP")
names(allSPP)
table(allSPP$SPP, allSPP$Int)

# Lifespan isn't exactly fair since same per genus but is a continous instead of a discrete variable
lm1 <- lm(Tulapprox ~ Freq*Int, data = allSPP)
lm2 <- lm(Tulapprox ~ Freq + Int + lifespan, data = allSPP)
lm3 <- lm(Tulapprox ~ Freq + Int, data = allSPP)
lm4 <-lm(Tulapprox ~ Freq, data = allSPP)
lm5 <-lm(Tulapprox ~ Int, data = allSPP) 
lm6 <-lm(Tulapprox ~ Freq + lifespan, data = allSPP)
lm7 <-lm(Tulapprox ~ Int + lifespan, data = allSPP) 

formulas <- list(lm1,lm2,lm3, lm4, lm5, lm6, lm7)
(lmresults <- aictab(formulas,
       modnames=as.character(unlist(lapply(formulas,formula)))))
evidence(aictab(cand.set = formulas,
                modnames = as.character(unlist(lapply(formulas,formula)))))


```







# --------------------------------- Older -------------------------------
######################################
Visualize difference between no harvest and each rate:freq per climate periodicity projection




Cycle through combinations of 0 to 100% of the frequency and intensities from no harvest, through equal rates regardless of good or bad, and all combinations.     
If I set this up as a continuous relationship (suggested by Anna) there would be fewer needed replicates and parameters, could vary the slope of the relationship instead of discrete percentages by good vs. bad.        
Either through a beta distribution; rbeta: two non-negative shape parameters where mean = a/(a+b) and variance is ab/((a+b)^2 *(a+b+1)) or a linear regression defining the slope     
```{r}

# Discrete rates
GBmatrix <- matrix(c(0.45,0.55,0.35,0.65), nrow=2, byrow = TRUE, dimnames = list(c("Good","Bad"), c("Good","Bad")))
Intensityrates <- cbind(rbind(seq(0.1,1,by=0.1),seq(0.1,1,by=0.1)),combn(seq(0,1,by=0.1),2))
FreqRates <- cbind(rbind(seq(0,1,by=0.1),seq(0,1,by=0.1)),combn(c(0,0.1,0.2,0.5,0.75,1),2))
sp <- unique(tm$SPP)[5]


# Keeping total years of the simulation and the good to bad year transition matrix constanst, compare time to exticntion for no harvest
compare_sp <- do.call(rbind, apply(Intensityrates, 2, function(i){
  outf <- do.call(rbind, apply(FreqRates, 2, function(f){
    compare_out <- do.call(rbind, lapply(1:100, function(x){
      out_rep <- SeedHarvestSim(Mx_list = Mx_all[grep(sp, unlist(Nx_names))], 
                                 TMx_list = TMx_all[grep(sp, unlist(Nx_names))],
                              Nx = stable.stage(mean(Mx_all[grep(sp, unlist(Nx_names))])),
                              StartPopSize = 500,
                              GoodBadTm = GBmatrix,
                              Freq = f,
                              Int = i,
                              TotYrs = 100,
                              ClusteredColl = 3)
      out_rep[[1]]$Replicate <- x
      out_rep[[1]]$Year <- 1:100
      out_rep[[1]]$GoodFreq <- f[1]
      out_rep[[1]]$BadFreq <- f[2]
      out_rep[[1]]$GoodInt <- i[1]
      out_rep[[1]]$BadInt <- i[2]
      out_rep[[1]]
      }))
    compare_out
    }))
  outf
  }))


splitXgoodFreq <- split(compare_sp, as.factor(compare_sp$GoodFreq))

ggplot(splitXgoodFreq[[1]][splitXgoodFreq[[1]]$BadFreq == 0.1,], aes(Year, PopulationSize, colour = as.factor(Replicate)))+
  geom_line()+
  theme(legend.position="none")+
  facet_wrap(~as.factor(GoodInt))
 
ggplot(compare_sp[compare_sp$GoodFreq == 1 & compare_sp$BadFreq == 1 & compare_sp$GoodInt == 1 & compare_sp$BadInt == 1 &
                    compare_sp$Replicate < 11,], aes(Year, PopulationSize, colour = as.factor(Replicate)))+
  geom_line()+
  theme(legend.position="none")+
  facet_wrap(~as.factor(Replicate))

time2extinct <- sapply(split(compare_DIFR, compare_DIFR$Replicate), function(x){
  which.max(x$PopulationSize<1) # To get the first year the population falls below 1
})

hist(time2extinct)

```













Example data for Sclerocactus glaucus where size measurements are the width at widest point for these ball cacti
't0' and 't1' are the widths (cm) and survival is for the tagged cactus from year t to t+1. 'reproyesno' is for 't0'. 'flowers0' is a Poisson distribution based on a linear model of number of flowers by size on the one year we took that data. 'minis0' and 'minis1' are the number of seedlings (cacti with < 0.5 cm in width) in year t and t+1

# Integral projeciton models
Merow et al 2014 Advancing population ecology   
```{r}

# make an S4 class object? 
params <- data.frame(
  surv.int=NA, # Intercept from logistic regression of survival
  surv.slope=NA, # Slope from logistic regression of survival
  growth.int=NA, # Intercept from linear regression of growth
  growth.slope=NA, # Slope from linear regression of growth
  growth.sd=NA, # Residual sd from the linear regression of growth
  seed.int=NA, # Intercept from Poisson regression of seed number
  seed.slope=NA, # Slope from Poisson regression of seed number
  recruit.size.mean=NA, # Mean recruit size
  recruit.size.sd=NA, # Standard deviation of recruit size
  establishment.prob=NA # Probability of establishment
)
```


# build vital rate regressions and store coefficients  
# Assume most populaitons will have different responses by site but check. Limitation might be due to sample (populaiton) size leading to lumping or splitting data by population. 
```{r}
# example data frame
size_scgl

# Test if there are differences in vital rates among sites and years

ggplot(size_scgl, aes(t0, survival, colour = Site))+
  geom_point()+
  theme_bw()+
  geom_jitter(height = 0.1, width = 0)+
  facet_wrap(~Site)+
  stat_smooth(method="glm", family=binomial, formula=y~x,
              alpha=0.2, size=1, colour="black")

ggplot(size_scgl, aes(t0, survival, colour = Site))+
  geom_point()+
  theme_bw()+
  geom_jitter(height = 0.1, width = 0)+
  facet_wrap(~year0)

# survival
surv.reg1 <- glm(survival ~ t0 + Site + as.factor(year0), data = size_scgl, family = binomial()) # survival by size (slope) comparing different intercepts by site and year
surv.reg2 <- glm(survival ~ t0, data = size_scgl, family = binomial()) # survival by size (slope)
# Could compare different slope and intercept by site and year but doesn't that overfit??

reg.list <- list(surv.reg1, surv.reg2)
reg.names <- as.character(unlist(lapply(reg.list, formula)))
(reg.results <- aictab(reg.list, modnames = reg.names))

summary(surv.reg1)

params$surv.int <- c(rep(coefficients(surv.reg1)[1], length(coefficients(surv.reg1))-2)+coefficients(surv.reg1)[-c(1:2)] )# all the offsets for year and site
```



# Code adapted from Dan Doak for an IPM

```{r}

# Unknown, test correlation of t-1, t-2 ... reproductive output on seedlings to see if there's an indication of a persistent seed bank
seedlings_per_seed_sg <- 10/500 # 0.000001 # the rate that a seed germinates I'm making a wild estimate

# Changed our methods from measuring all individuals to only measuring individuals >= 0.5 cm width in 2012. 
surv_minis <- 0.69 # this is an average of two estimates, should test both 0.59 and 0.78

# set the minimum size and maximum size
minsize_scgl <- 0.01
maxsize_scgl <- 12.61 # was Fram, excluded 14.51

```


Size density estimation for median size estimation - for each kernel, the state of an individual at one time that dictates the state and state of any offspring at the next time step (Merow et al. 2014 "Advancing population ecology with integral projeciton models: a practical guide")
```{r}

pdfsz_scgl <- density(size_scgl$t0, n=1024, cut=0, na.rm = TRUE)
pdfsz2_scgl <- cbind(pdfsz_scgl$x,pdfsz_scgl$y)
plot(pdfsz2_scgl, type="l")

```

### Matrix Model 
  Estimate vital rates, populate matrix, for models with different numbers of classes/ bins    

```{r ScGl matrix}
# testing
# seedlings_per_seed <- seedlings_per_seed_sg # not sure if this should be the chance a seed turns into a seedling or something else or how to pick the value
# testbins <- c(4,5,6,7,8,10,15,19) # I don't have enough individuals to get estimates if I break this into too many bins
# df <- size_scgl
# minsize <- minsize_scgl
# maxsize <- maxsize_scgl
# bin.num <- testbins
# allsdszs <- allsdszs_scgl # the distribution of sizes you classify as a seedling
# surv_seedlings <- surv_minis # calculated from using the size class defined as seedlings in time t and the annual surival to t+1; seedling size vs. the smallest bin size which might include more than survival of seedlings
# bin.num <-  c(4,5,6,7,8)
# i <- 3
# seeds_per_flower <- 150
# rm(bin.num); rm(i); rm(df);rm(seedlings_per_seed);rm(minsize); rm(maxsize); rm(allsdszs); rm(surv_seedlings); rm(seeds_per_flower)

IPM_basic <- function(df, bin.num, seedlings_per_seed, surv_seedlings, seeds_per_flower, seedling_size){
    # Empty list items
    lambdas_matrix <- rep(NA, length(bin.num))
    dampratio_matrix = rep(NA, length(bin.num))
    lifespan_matrix=rep(NA, length(bin.num))
    mincounts=NULL
    minsize <- min(c(df$t0, df$t1), na.rm=TRUE) -0.01
    maxsize <- max(c(df$t0, df$t1), na.rm=TRUE) +0.01
    allsdszs <- df$t0[df$t0 < seedling_size]
    # test each number of bins, break by size 
    for(i in 1:length(bin.num)){
      ss=as.numeric(df$t0)
      vec.bin = c(minsize, minsize+1:bin.num[i]*(maxsize-minsize)*(1/bin.num[i])) # the upper and lower size limits to make the designated number of bins
      nums=hist(ss,breaks=vec.bin, plot=FALSE)$counts  # the number of individuals that fall in each group
      mincounts=c(mincounts,min(nums))
      
      if (min(nums)>2) {  
        ## Initialize storage
        n.bin <- length(vec.bin)-1            # this is a workaround
        n <- rep(NA, n.bin)                   # count of indvs per bin
        medians <- rep(NA, n.bin)             # median size per bin for F
        surv <- rep(NA, n.bin)                # survivorship for each class
        grow <- matrix(NA, n.bin, n.bin)      # store growth probabilites for each class
        reproduction <- rep(NA, n.bin)        # store reproduction probabilites for each class
        
        totnums = 0 # this is just monitoring for errors, start at zero before next loop per size subset
        # bin, survival, growth
         for(j in 1:(length(vec.bin)-1)){
          # set limits for size subset according to bin breaks
          bounds <- c(vec.bin[j], vec.bin[j+1])
          # subset data according to bounds
          subset <- df[df$t0 > bounds[1] & df$t0 <= bounds[2],]
          # store number of inviduals in this bin for future reference
          n[j] <- length(subset$t0)
          medians[j] <- median(subset$t0)
          # calculate survivorship for this class
          surv[j] <- sum(subset$survival) / length(subset$t0) # of those alive in year 1, how many survived by bin/size class
          # store histo as object, to access counts per bin
          histo <- hist(subset$t1, breaks = vec.bin, plot = FALSE)
          # $counts returns the number of individuals of a certain size class
          grow[,j] <- histo$counts/length(subset$t0[subset$survival==1]) 
          reproduction[j] <- mean(subset$flowers0*seeds_per_flower, na.rm = TRUE) # seedlings produced per plant in start yr
          
          totnums = totnums + sum(histo$counts)
        }
        
        # make a vector of the prob of seedling sizes: 
        sdlggrow <- hist(allsdszs, breaks = vec.bin, plot = FALSE)$counts/length(allsdszs)
        reproduction[is.nan(reproduction)] <- 0
        
        M1 <- matrix(NA, n.bin, n.bin)   # initiate projection matrix
        M <- matrix(0, (n.bin+1), (n.bin+1))
        # populate projection matrix
      
        for(j in 1:length(surv)){
          M1[,j] <- surv[j] * grow[,j]
          M1[,j] <- (surv[j] * grow[,j])
        }
          
          # add lines for the creation of bulblings and thier transition to first size class
          M[2:(n.bin+1), 2:(n.bin+1)] = M1
          M[2:(n.bin+1),1] = surv_seedlings*sdlggrow 
          M[1,2:(n.bin+1)] = reproduction*seedlings_per_seed  
        
        
        lambdas_matrix[i] <- lambda(M) # calls popbio f'n 'lambda'
        dampratio_matrix[i]=damping.ratio(M)
        lifespan_matrix[i] =lifespan(M)
        
        print(c(i,totnums)) 
      } else {
        lambdas_matrix[i]=NA
        dampratio_matrix[i] = NA
        lifespan_matrix[i] = NA
      }
    }
    list(lambdas_matrix, dampratio_matrix, lifespan_matrix)
}
```






Not by site but across all data, use site, year, and fecundity as a covariate, predict for high and low values 
```{r}
# ScGl
# seedlings_per_seed # not sure if this should be the chance a seed turns into a seedling or something else or how to pick the value
testbins <- c(4,5,6,10,30,50,100) # I don't have enough individuals to get estimates if I break this into too many bins
# df <- size_scgl
# minsize <- minsize_scgl
# maxsize <- maxsize_scgl
# bin.num <- testbins
# allsdszs <- allsdszs_scgl # the distribution of sizes you classify as a seedling
# surv_seedlings <- surv_minis # calculated from using the size class defined as seedlings in time t and the annual surival to t+1; seedling size vs. the smallest bin size which might include more than survival of seedlings

scgl_IPM_all <- IPM_basic(df = size_scgl, seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150, seedling_size = 0.5)

scgl_IPM_all


scgl_IPM_NS <- lapply(unique(size_scgl$Region), function(x){
  IPM_basic(df = size_scgl[size_scgl$Region == x,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150,  seedling_size = 0.5)
  })

sites <- c("Atwell Gulch","Picnic Site","Powerline","Pyramid Rock","T-Junction")
 #unique(size_scgl$Site)
scgl_IPM_sites <- lapply(c("Atwell Gulch","Escalante Canyon","Picnic Site","Pyramid Rock"), function(x){
  print(x)
  IPM_basic(df = size_scgl[size_scgl$Site == x,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins,  seedling_size = 0.5, surv_seedlings = surv_minis, seeds_per_flower = 150)
})

# Errors -Inf
scgl_IPM_Site_year <- lapply(c("Atwell Gulch","Escalante Canyon","Picnic Site","Pyramid Rock"), function(x){
  lapply(unique(size_scgl$year0[size_scgl$Site == x]), function(y){
    print(x);print(y)
  IPM_basic(df = size_scgl[size_scgl$Region == x & size_scgl$year0 == y,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150,  seedling_size = 0.5)
  })
})


scgl_IPM_NS_year <- lapply(unique(size_scgl$Region), function(x){
  lapply(unique(size_scgl$year0[size_scgl$Region == x]), function(y){
    print(x);print(y)
  IPM_basic(df = size_scgl[size_scgl$Region == x & size_scgl$year0 == y,], seedlings_per_seed = seedlings_per_seed_sg, bin.num = testbins, surv_seedlings = surv_minis, seeds_per_flower = 150,  seedling_size = 0.5)
  })
})


```


```{r}
(lambdas_matrix)
(dampratio_matrix)
(lifespan_matrix)

```

Make a predictive model (as a function only of size in this case) and site, year, and fecundity for each demographic rate: survival, mean growth, variance in growth, prob of reproducing, and how much reproduction if reproducing. The code fits a few alternatives and chooses the best one for each rate, which will be used below. But can't have fecundity in the reproductive ones... ???
```{r}
## Vital rates
# survival
######## ScGl survival #########################
# do it my way 

glm1 <- glm(survival ~ t0, family = "binomial", data = size_scgl)
# glm2 <- glm(survival ~ t0 + t0sq, family = "binomial", data = size_scgl) # don't have a squared term yet, need it?
glm3 <- glm(survival ~ t0 + Site + t0*Site, family = "binomial", data = size_scgl1) # The slope and the intecept could differ
glm4 <- glm(survival ~ t0 + as.factor(year0) + t0*year0, family = "binomial", data = size_scgl1)
glm5 <- glm(survival ~ t0 + as.factor(year0) + t0*as.factor(year0) + Site + t0*Site + as.factor(year0)*Site, family = "binomial", data = size_scgl1)

lm.list <- list(glm1, glm3, glm4, glm5)
lm.names <- as.character(unlist(lapply(lm.list, formula)))
(lm.results <- aictab(lm.list, modnames = lm.names))
# evidence ratio
for(i in 2:length(lm.list)){
  print(exp(0.5*lm.results$Delta_AICc[i]))
}

summary(glm5)

ggplot(size_scgl, aes(t0, survival, colour = Site))+
  geom_point()+
  stat_smooth(method="glm", family=binomial, formula = y~x, aes(fill=Site))+
  facet_grid(cols=vars(year0),
             rows = vars(Site))+
  xlab("Size at time t")+
  ylab("Survival to time t+1")+
  theme_bw()

```


```{r}
# Growth

# growth: non-linear with linear function of size , quadratic function of size, power function (A+B*(size^C))
# nlm1 <- nls(t1 ~ a + b*t0, data = size_scgl, start = list(a=1, b=1))
# nlm2 <- nls(t1 ~ a + b*t0 + c*Site, data=size_scgl, start = (list(a=1, b=1, c=1)))
# nlm3 <- nls(t1 ~ a + b*t0 + c*year0, data=size_scgl, start=list(a=1, b=1, c=1))

glm1 <- glm(t1 ~ t0, family = poisson, data = size_scgl)
nlm.list <- list(nlm1, nlm2, nlm3)
nlm.names <- as.character(unlist(lapply(nlm.list, formula)))
(nlm.results <- aictab(nlm.list, modnames = nlm.names))
for(i in 2:length(nlm.list)){
  print(exp(0.5*nlm.results$Delta_AICc[i]))
}

# getting residuals of growth
size$growth_residuals <- NA
size$growth_residuals[which(!is.na(size$t1) & !is.na(size$t0))] <- summary(bestgrowth)$residuals^2

summary(glm1)

```



# code snipit graveyard

# Sensitivities and elasticites    
<http://ecovirtual.ib.usp.br/doku.php?id=en:ecovirt:roteiro:pop_str:pstr_ser> 
```{r}
eigen.all <- lapply(Mx_all, function(mx){
  eigen(mx)
})

# transposed to get w: stable stage vector
# Or to get reproductive values because the left eigenvectors are equal to the right eigenvectors of the transpose matrix. i.e. you transpose and use eigen() to find the left eigenvector - the eigenvalues will be the same
eigen.tall <- lapply(Mx_all, function(mx){
  eigen(t(mx))
})

lamb.all <- lapply(eigen.all, function(x){
  max(Re(x$values)) # check if lambda 1 agrees with the expected
})

v.all <- lapply(eigen.all, function(x){
  Re(x$vectors[,which.max(Re(x$values))]) # proportional reproductive value
})

# ???standardized reproductive value
vr.all <- lapply(v.all, function(x){
  x/x[1]
})

w.all <- lapply(eigen.tall, function(x){
  Re(x$vectors[,which.max(Re(x$values))]) # stable stage vector
})

wsum.all <- lapply(w.all, function(x){
  x/sum(x)
})

# ???
# <http://biom300.weebly.com/eigenvalues-and-eigenvectors-in-r.html> 
# divide by the first non-zero entry to calcuate relative reproductive values (should be the same as vr.all above) but is not
repro.value <- mapply(function(l,r) l$vectors[,1]/r$vectors[1,1] ,eigen.tall, eigen.all)
stable.stages <- lapply(Mx_all, function(x){
  eigen(x)$vectors[,1]/(sum(eigen(x)$vectors[,1]))
})

# mean reproductive value 
mean.repro <- mapply(function(r,s) r%*%s, repro.value, stable.stages)
unlist(mean.repro)

### Sensitivity
vms.all <- mapply(function(v,w) v %*% t(w), vr.all, w.all)
S.all <- mapply(function(vms, vr, w) vms/as.numeric(vr %*% w), vms.all, vr.all, w.all)


### Elasticity
elast <- mapply(function(mx, l, Ss) (mx/l)*Ss, Mx_all, lamb.all, S.all)

### Compare to popbio()
ea.all <- lapply(Mx_all, function(x) eigen.analysis(x))


eigen.all[[1]];eigen.tall[[1]];lamb.all[[1]];v.all[[1]];S.all[[1]];vmx.all[[1]];ea.all[[1]]
vr.all[[1]];elast[[1]]

cory<-matrix(c(0.434, 0.333,0,0,0.61, 0.304,0.56, 0, 0.956), ncol=3, nrow=3)
cory
n0=matrix(c(10,5,2), ncol=1)
## tempo 1
	n1 <-  cory %*% n0 
	n1[3] <- n1[3]-0.2 * n1[3] # simulates a 20% post-reproductive extraction of adulats

eigen.analysis(cory)
```




```{r}

pathstart <- "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - Demography/SeedHarvestModelling/Seed_Harvest_Modeling/Simulation_output/"

ncores <- detectCores()-1
cl <- makeCluster(ncores)
doParallel::registerDoParallel(cl, ncores)

# i<- 0.1
# xfile <- resultpath[[1]]

compars <- lapply(seq(0.1,1,by=0.1),function(i){  #
  resultpath <- list.files(path = pathstart, 
                           pattern = paste("Cluster1AvgInt",i,"Freq","0.1",sep=""),
                           full.names = TRUE)
  foreach(xfile  = resultpath,
          .combine = "rbind") %dopar% {
            load(xfile)
            out
            }
  })
stopCluster(cl)

head(compars)


```

      if(ddceiling == TRUE){ # instead use some stochastic process (see Anna's paper) to multiple and still have a matrix reflecting seed harvest,
        # option 1: in absence of transition-specific density dependence (but maybe there is more likely more seed production at greater densities - remove pollen limitation, but lower recruitment survival due to high densities) then a straight across classes lowering of number of individuals in each stage by the difference between total population size and maximum population size as the logistic term - replace growth rate by the dominant eigenvalue of the transition matrix.  
        # A hard cap or ceiling negates the effect of seed harvest
      if(sum(onetransition[[1]]) < ceil){
        vec <- onetransition[[1]]
        }
      } else {
        vec <- onetransition[[1]]
        } # done with density dependent ceiling
      } # end density dependence
